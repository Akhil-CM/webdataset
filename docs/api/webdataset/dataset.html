<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 7.0.2" />
    <title>webdataset.dataset API documentation</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%20viewBox%3D%2244.5%202.5%2015%2015%22%3E%3Cpath%20d%3D%22M49.351%2021.041c-.233-.721-.546-2.408-.772-4.076-.042-.09-.067-.187-.046-.288-.166-1.347-.277-2.625-.241-3.351-1.378-1.008-2.271-2.586-2.271-4.362%200-.976.272-1.935.788-2.774.057-.094.122-.18.184-.268-.033-.167-.052-.339-.052-.516%200-1.477%201.202-2.679%202.679-2.679.791%200%201.496.352%201.987.9a6.3%206.3%200%200%201%201.001.029c.492-.564%201.207-.929%202.012-.929%201.477%200%202.679%201.202%202.679%202.679a2.65%202.65%200%200%201-.269%201.148c.383.747.595%201.572.595%202.41%200%202.311-1.507%204.29-3.635%205.107.037.699.147%202.27.423%203.294l.137.461c.156%202.136-4.612%205.166-5.199%203.215zm.127-4.919a4.78%204.78%200%200%200%20.775-.584c-.172-.115-.505-.254-.88-.378zm.331%202.302l.828-.502c-.202-.143-.576-.328-.984-.49zm.45%202.157l.701-.403c-.214-.115-.536-.249-.891-.376l.19.779zM49.13%204.141c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm.735-.389a1.15%201.15%200%200%201%20.314.783%201.16%201.16%200%200%201-1.162%201.162c-.457%200-.842-.27-1.032-.653-.026.117-.042.238-.042.362a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.843-.626-1.535-1.436-1.654zm3.076%201.654a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.037-.009-.072-.011-.109-.21.3-.541.508-.935.508a1.16%201.16%200%200%201-1.162-1.162%201.14%201.14%200%200%201%20.474-.912c-.015%200-.03-.005-.045-.005-.926.001-1.679.754-1.679%201.68zm1.861-1.265c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm1.823%204.823c0-.52-.103-1.035-.288-1.52-.466.394-1.06.64-1.717.64-1.144%200-2.116-.725-2.499-1.738-.383%201.012-1.355%201.738-2.499%201.738-.867%200-1.631-.421-2.121-1.062-.307.605-.478%201.267-.478%201.942%200%202.486%202.153%204.51%204.801%204.51s4.801-2.023%204.801-4.51zm-3.032%209.156l-.146-.492c-.276-1.02-.395-2.457-.444-3.268a6.11%206.11%200%200%201-1.18.115%206.01%206.01%200%200%201-2.536-.562l.006.175c.802.215%201.848.612%202.021%201.25.079.295-.021.601-.274.837l-.598.501c.667.304%201.243.698%201.311%201.179.02.144.022.507-.393.787l-.564.365c1.285.521%201.361.96%201.381%201.126.018.142.011.496-.427.746l-.854.489c.064-1.19%201.985-2.585%202.697-3.248zM49.34%209.925c0-.667%201-.667%201%200%200%20.653.818%201.205%201.787%201.205s1.787-.552%201.787-1.205c0-.667%201-.667%201%200%200%201.216-1.25%202.205-2.787%202.205s-2.787-.989-2.787-2.205zm-.887-7.633c-.093.077-.205.114-.317.114a.5.5%200%200%201-.318-.886L49.183.397a.5.5%200%200%201%20.703.068.5.5%200%200%201-.069.703zm7.661-.065c-.086%200-.173-.022-.253-.068l-1.523-.893c-.575-.337-.069-1.2.506-.863l1.523.892a.5.5%200%200%201%20.179.685c-.094.158-.261.247-.432.247z%22%20fill%3D%22%233bb300%22/%3E%3C/svg%3E"/>


<style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
<style>/*! pygments syntax highlighting */pre{line-height:125%;}td.linenos pre{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}span.linenos{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}td.linenos pre.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}span.linenos.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}.pdoc .hll{background-color:#ffffcc}.pdoc{background:#f8f8f8;}.pdoc .c{color:#408080; font-style:italic}.pdoc .err{border:1px solid #FF0000}.pdoc .k{color:#008000; font-weight:bold}.pdoc .o{color:#666666}.pdoc .ch{color:#408080; font-style:italic}.pdoc .cm{color:#408080; font-style:italic}.pdoc .cp{color:#BC7A00}.pdoc .cpf{color:#408080; font-style:italic}.pdoc .c1{color:#408080; font-style:italic}.pdoc .cs{color:#408080; font-style:italic}.pdoc .gd{color:#A00000}.pdoc .ge{font-style:italic}.pdoc .gr{color:#FF0000}.pdoc .gh{color:#000080; font-weight:bold}.pdoc .gi{color:#00A000}.pdoc .go{color:#888888}.pdoc .gp{color:#000080; font-weight:bold}.pdoc .gs{font-weight:bold}.pdoc .gu{color:#800080; font-weight:bold}.pdoc .gt{color:#0044DD}.pdoc .kc{color:#008000; font-weight:bold}.pdoc .kd{color:#008000; font-weight:bold}.pdoc .kn{color:#008000; font-weight:bold}.pdoc .kp{color:#008000}.pdoc .kr{color:#008000; font-weight:bold}.pdoc .kt{color:#B00040}.pdoc .m{color:#666666}.pdoc .s{color:#BA2121}.pdoc .na{color:#7D9029}.pdoc .nb{color:#008000}.pdoc .nc{color:#0000FF; font-weight:bold}.pdoc .no{color:#880000}.pdoc .nd{color:#AA22FF}.pdoc .ni{color:#999999; font-weight:bold}.pdoc .ne{color:#D2413A; font-weight:bold}.pdoc .nf{color:#0000FF}.pdoc .nl{color:#A0A000}.pdoc .nn{color:#0000FF; font-weight:bold}.pdoc .nt{color:#008000; font-weight:bold}.pdoc .nv{color:#19177C}.pdoc .ow{color:#AA22FF; font-weight:bold}.pdoc .w{color:#bbbbbb}.pdoc .mb{color:#666666}.pdoc .mf{color:#666666}.pdoc .mh{color:#666666}.pdoc .mi{color:#666666}.pdoc .mo{color:#666666}.pdoc .sa{color:#BA2121}.pdoc .sb{color:#BA2121}.pdoc .sc{color:#BA2121}.pdoc .dl{color:#BA2121}.pdoc .sd{color:#BA2121; font-style:italic}.pdoc .s2{color:#BA2121}.pdoc .se{color:#BB6622; font-weight:bold}.pdoc .sh{color:#BA2121}.pdoc .si{color:#BB6688; font-weight:bold}.pdoc .sx{color:#008000}.pdoc .sr{color:#BB6688}.pdoc .s1{color:#BA2121}.pdoc .ss{color:#19177C}.pdoc .bp{color:#008000}.pdoc .fm{color:#0000FF}.pdoc .vc{color:#19177C}.pdoc .vg{color:#19177C}.pdoc .vi{color:#19177C}.pdoc .vm{color:#19177C}.pdoc .il{color:#666666}</style>
<style>/*! pdoc */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f7f7f7;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}body{background-color:var(--pdoc-background);}html, body{width:100%;height:100%;}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}.git-button{display:none !important;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}#navtoggle{display:none;}}#togglestate{display:none;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{--shift:-40px;text-align:right;margin-top:var(--shift);margin-bottom:calc(0px - var(--shift));clear:both;filter:opacity(1);}.pdoc details:not([open]){height:0;overflow:visible;}.pdoc details > summary{font-size:.75rem;cursor:pointer;color:var(--muted);border-width:0;padding:0 .7em;display:inline-block;display:inline list-item;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc details > div{margin-top:calc(0px - var(--shift) / 2);text-align:left;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:3rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:1rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}</style>
</head>
<body>        <nav class="pdoc">
            <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
            <input id="togglestate" type="checkbox">
            <div>
                        <a class="pdoc-button module-list-button" href="../webdataset.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                            &nbsp;webdataset</a>

                    <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                           pattern=".+" required>




                    <h2>API Documentation</h2>
                        <ul class="memberlist">
            <li>
                    <a class="class" href="#MockDataset">MockDataset</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#MockDataset.__init__">MockDataset</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="function" href="#warn_no_samples">warn_no_samples</a>
            </li>
            <li>
                    <a class="class" href="#Composable">Composable</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Composable.__init__">Composable</a>
                        </li>
                        <li>
                                <a class="function" href="#Composable.source_">source_</a>
                        </li>
                        <li>
                                <a class="function" href="#Composable.then">then</a>
                        </li>
                        <li>
                                <a class="function" href="#Composable.compose">compose</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#ShardList">ShardList</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#ShardList.__init__">ShardList</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#BatchedLength">BatchedLength</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#BatchedLength.__init__">BatchedLength</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#Shorthands">Shorthands</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Shorthands.__init__">Shorthands</a>
                        </li>
                        <li>
                                <a class="function" href="#Shorthands.batched">batched</a>
                        </li>
                        <li>
                                <a class="function" href="#Shorthands.unbatched">unbatched</a>
                        </li>
                        <li>
                                <a class="function" href="#Shorthands.shuffle">shuffle</a>
                        </li>
                        <li>
                                <a class="function" href="#Shorthands.map">map</a>
                        </li>
                        <li>
                                <a class="function" href="#Shorthands.decode">decode</a>
                        </li>
                        <li>
                                <a class="function" href="#Shorthands.rename">rename</a>
                        </li>
                        <li>
                                <a class="function" href="#Shorthands.map_dict">map_dict</a>
                        </li>
                        <li>
                                <a class="function" href="#Shorthands.select">select</a>
                        </li>
                        <li>
                                <a class="function" href="#Shorthands.to_tuple">to_tuple</a>
                        </li>
                        <li>
                                <a class="function" href="#Shorthands.map_tuple">map_tuple</a>
                        </li>
                        <li>
                                <a class="function" href="#Shorthands.dbcache">dbcache</a>
                        </li>
                        <li>
                                <a class="function" href="#Shorthands.associate">associate</a>
                        </li>
                        <li>
                                <a class="function" href="#Shorthands.slice">slice</a>
                        </li>
                        <li>
                                <a class="function" href="#Shorthands.rsample">rsample</a>
                        </li>
                        <li>
                                <a class="function" href="#Shorthands.repeat">repeat</a>
                        </li>
                        <li>
                                <a class="function" href="#Shorthands.test">test</a>
                        </li>
                        <li>
                                <a class="function" href="#Shorthands.ddp_equalize">ddp_equalize</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#Repeatedly">Repeatedly</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Repeatedly.__init__">Repeatedly</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#Processor">Processor</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Processor.__init__">Processor</a>
                        </li>
                        <li>
                                <a class="function" href="#Processor.source_">source_</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="function" href="#WebDataset">WebDataset</a>
            </li>
            <li>
                    <a class="function" href="#WebLoader">WebLoader</a>
            </li>
            <li>
                    <a class="class" href="#DatasetTest">DatasetTest</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#DatasetTest.__init__">DatasetTest</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#ChoppedDataset">ChoppedDataset</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#ChoppedDataset.__init__">ChoppedDataset</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#ResizedDataset">ResizedDataset</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#ResizedDataset.__init__">ResizedDataset</a>
                        </li>
                </ul>

            </li>
    </ul>


                    <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
                        built with <span class="visually-hidden">pdoc</span><img
                            alt="pdoc logo"
                            src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
                    </a>
            </div>
        </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
<a href="./../webdataset.html">webdataset</a><wbr>.dataset    </h1>

                        <div class="docstring"><p>Train PyTorch models directly from POSIX tar archive.</p>

<p>Code works locally or over HTTP connections.</p>
</div>

                        <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="c1">#</span>
<span class="c1"># Copyright (c) 2017-2021 NVIDIA CORPORATION. All rights reserved.</span>
<span class="c1"># This file is part of the WebDataset library.</span>
<span class="c1"># See the LICENSE file for licensing terms (BSD-style).</span>
<span class="c1">#</span>


<span class="sd">&quot;&quot;&quot;Train PyTorch models directly from POSIX tar archive.</span>

<span class="sd">Code works locally or over HTTP connections.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">itt</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">braceexpand</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">autodecode</span><span class="p">,</span> <span class="n">dbcache</span><span class="p">,</span> <span class="n">iterators</span><span class="p">,</span> <span class="n">shardcache</span><span class="p">,</span> <span class="n">tariterators</span><span class="p">,</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">lookup_sym</span><span class="p">,</span> <span class="n">safe_eval</span>
<span class="kn">from</span> <span class="nn">.handlers</span> <span class="kn">import</span> <span class="n">reraise_exception</span>
<span class="kn">from</span> <span class="nn">.workerenv</span> <span class="kn">import</span> <span class="n">split_by_node</span><span class="p">,</span> <span class="n">split_by_worker</span><span class="p">,</span> <span class="n">get_worker_environment</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">IterableDataset</span><span class="p">,</span> <span class="n">DataLoader</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.mock</span> <span class="kn">import</span> <span class="n">IterableDataset</span><span class="p">,</span> <span class="n">DataLoader</span>


<span class="n">default_cache_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;WEBDATASET_CACHE&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
<span class="n">default_cache_name</span> <span class="o">=</span> <span class="n">lookup_sym</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;WEBDATASET_CACHE_NAME&quot;</span><span class="p">,</span> <span class="s2">&quot;shard_uuid&quot;</span><span class="p">),</span> <span class="s2">&quot;.shardcache&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="n">default_cache_verbose</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">safe_eval</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;WEBDATASET_CACHE_VERBOSE&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">)))</span>
<span class="n">default_cache_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">safe_eval</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;WEBDATASET_CACHE_SIZE&quot;</span><span class="p">,</span> <span class="s2">&quot;1e15&quot;</span><span class="p">))))</span>


<span class="k">class</span> <span class="nc">MockDataset</span><span class="p">(</span><span class="n">IterableDataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;MockDataset.</span>

<span class="sd">    A mock dataset for performance testing and unit testing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a mock dataset instance.</span>

<span class="sd">        :param sample: the sample to be returned repeatedly</span>
<span class="sd">        :param length: the length of the mock dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span> <span class="n">sample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the length of this mock dataset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator over this mock dataset.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample</span>


<span class="k">def</span> <span class="nf">warn_no_samples</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Warn if the iterator yields no samples.&quot;&quot;&quot;</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">sample</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">env</span> <span class="o">=</span> <span class="n">get_worker_environment</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">env</span><span class="o">.</span><span class="n">rank</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;no samples at all in node </span><span class="si">{</span><span class="n">env</span><span class="o">.</span><span class="n">rank</span><span class="si">}</span><span class="s2">, worker </span><span class="si">{</span><span class="n">env</span><span class="o">.</span><span class="n">worker</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Composable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A mixin implementing composability of data pipelines.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the composable mixin.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">source_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the source for this dataset.</span>

<span class="sd">        :param source: source dataset, should be an IterableDataset instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">then</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compose this processor with a new processor defined by a function.</span>

<span class="sd">        The function is of the form:</span>

<span class="sd">            def my_process(source, ...):</span>
<span class="sd">                for sample in source:</span>
<span class="sd">                    ...</span>
<span class="sd">                    result = ...</span>
<span class="sd">                    yield result</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">assert</span> <span class="s2">&quot;source&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span>
        <span class="c1"># print(&quot;Processor&quot;, args, kw)</span>
        <span class="k">return</span> <span class="n">Processor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constructor</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compose this processor with another IterableDataset.</span>

<span class="sd">        The constructor should be of the form `__init__(self, source_dataset, ...)`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">constructor</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">constructor</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span><span class="o">.</span><span class="n">source_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ShardList</span><span class="p">(</span><span class="n">IterableDataset</span><span class="p">,</span> <span class="n">Composable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An iterable dataset yielding a list of urls.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">urls</span><span class="p">,</span>
        <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">nodesplitter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">splitter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a ShardList.</span>

<span class="sd">        :param urls: a list of URLs as a Python list or brace notation string</span>
<span class="sd">        :param shuffle: whether to shuffle the URLs</span>
<span class="sd">        :param nodesplitter: function for splitting urls across nodes (None: don&#39;t split)</span>
<span class="sd">        :param splitter: function for splitting urls across workers (None: don&#39;t split)</span>
<span class="sd">        :param length: user-specified length; this is returned unchanged by the len() function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span> <span class="o">=</span> <span class="n">shuffle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="k">if</span> <span class="n">nodesplitter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodesplitter</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">identity</span>
        <span class="k">elif</span> <span class="n">nodesplitter</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodesplitter</span> <span class="o">=</span> <span class="n">split_by_node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">nodesplitter</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodesplitter</span> <span class="o">=</span> <span class="n">nodesplitter</span>
        <span class="k">if</span> <span class="n">splitter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">splitter</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">identity</span>
        <span class="k">elif</span> <span class="n">splitter</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">splitter</span> <span class="o">=</span> <span class="n">split_by_worker</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">splitter</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">splitter</span> <span class="o">=</span> <span class="n">splitter</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">urls</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">urls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">braceexpand</span><span class="o">.</span><span class="n">braceexpand</span><span class="p">(</span><span class="n">urls</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">urls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">urls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">urls</span> <span class="o">=</span> <span class="n">urls</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">urls</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator over the shards.&quot;&quot;&quot;</span>
        <span class="n">urls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">urls</span><span class="p">)</span>
        <span class="n">urls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodesplitter</span><span class="p">(</span><span class="n">urls</span><span class="p">))</span>
        <span class="n">urls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splitter</span><span class="p">(</span><span class="n">urls</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">urls</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="p">:</span>
            <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">urls</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">:</span>
            <span class="k">yield</span> <span class="nb">dict</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the user-specified length of this dataset.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;length requested, but no length specified for ShardIterator&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>


<span class="k">class</span> <span class="nc">BatchedLength</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute the batched length of a dataset.</span>

<span class="sd">    We make this a class rather than a closure so that it can be pickled.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batchsize</span><span class="p">,</span> <span class="n">partial</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize.</span>

<span class="sd">        :param batchsize: batch size</span>
<span class="sd">        :param partial: allow partial batches</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batchsize</span> <span class="o">=</span> <span class="n">batchsize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">partial</span> <span class="o">=</span> <span class="n">partial</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the number of batches for the given length.</span>

<span class="sd">        :param length: number of samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Add +1 when partial batch is allowed</span>
        <span class="n">partial_batch</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">length</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">batchsize</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="c1"># True or False</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">length</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">batchsize</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">partial</span> <span class="ow">and</span> <span class="n">partial_batch</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Shorthands</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A convenient set of shorthands for common data transformations.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">batched</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batchsize</span><span class="p">,</span> <span class="n">collation_fn</span><span class="o">=</span><span class="n">iterators</span><span class="o">.</span><span class="n">default_collation_fn</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute batches for the given dataset.</span>

<span class="sd">        :param batchsize: desired batchsize</span>
<span class="sd">        :param collation_fn: collation function to turn list of objects into batches</span>
<span class="sd">        :param partial: return partial batches</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">BatchedLength</span><span class="p">(</span><span class="n">batchsize</span><span class="p">,</span> <span class="n">partial</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span>
            <span class="n">iterators</span><span class="o">.</span><span class="n">batched</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="n">batchsize</span><span class="o">=</span><span class="n">batchsize</span><span class="p">,</span> <span class="n">collation_fn</span><span class="o">=</span><span class="n">collation_fn</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="n">partial</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Take a stream of batches and turn it back into a stream of samples.</span>

<span class="sd">        :param length: user-supplied length for the unbatched dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">unbatched</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shuffle the dataset using an internal shuffle buffer.</span>

<span class="sd">        This will buffer up `initial` samples. Then it will add new samples to</span>
<span class="sd">        the internal buffer and return random samples from the buffer, simultaneously</span>
<span class="sd">        filling up the buffer to the given size.</span>

<span class="sd">        Using initial &lt; size will result in less initial randomness but faster</span>
<span class="sd">        startups.</span>

<span class="sd">        :param size: size of the shuffle buffer</span>
<span class="sd">        :param initial: buffer this many samples before yield training samples</span>
<span class="sd">        :param handler: The exception handling strategy.</span>
<span class="sd">        :param kw: other keywords for iterators.shuffle</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">shuffle</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">reraise_exception</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Map a function over a stream of samples.</span>

<span class="sd">        This may be a tuple stream or a stream of dicts.</span>

<span class="sd">        :param f: The function to be mapped.</span>
<span class="sd">        :param handler: The exception handling strategy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">map</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">handler</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">pre</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">post</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">handler</span><span class="o">=</span><span class="n">reraise_exception</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Decode samples.</span>

<span class="sd">        This is a special form of mapping over samples given as dicts.</span>
<span class="sd">        A list of all decoders is formed from `pre + args + post`.</span>
<span class="sd">        For each dict entry, the decoders on that list are invoked in sequence</span>
<span class="sd">        until one of them decodes the sample. That decoded value is then stored</span>
<span class="sd">        in the dictionary and the next dictionary entry is decoded.</span>

<span class="sd">        The `pre` and `post` decoder lists are set to common defaults (including `.gz` decoding).</span>
<span class="sd">        You can specify decoders for your application in the `args` argument.</span>
<span class="sd">        String arguments like &quot;pil&quot; are a shorthand for image decoder functions like</span>
<span class="sd">        `webdataset.imagehandler(&quot;pil&quot;)`. All other decoders must be specified as</span>
<span class="sd">        functions.</span>

<span class="sd">        :param args: list of decoder functions; a string like &quot;pil&quot; is a shorthand for common image decoders</span>
<span class="sd">        :param pre: a list of decoder functions that is always carried out before args</span>
<span class="sd">        :param post: a list of decoder functions that is always carried out after args</span>
<span class="sd">        :param only: limit decoding to the list of these fields</span>
<span class="sd">        :param handler: exception handler</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># for backwards compatibility</span>
        <span class="n">handlers</span> <span class="o">=</span> <span class="p">[</span><span class="n">autodecode</span><span class="o">.</span><span class="n">ImageHandler</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">h</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
        <span class="n">decoder</span> <span class="o">=</span> <span class="n">autodecode</span><span class="o">.</span><span class="n">Decoder</span><span class="p">(</span><span class="n">handlers</span><span class="p">,</span> <span class="n">pre</span><span class="o">=</span><span class="n">pre</span><span class="p">,</span> <span class="n">post</span><span class="o">=</span><span class="n">post</span><span class="p">,</span> <span class="n">only</span><span class="o">=</span><span class="n">only</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">decoder</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">handler</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">reraise_exception</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rename fields in a dictionary based sample.</span>

<span class="sd">        This works on dictionary input streams. A keyword argument like</span>
<span class="sd">        `new=&quot;old&quot;` renames extension/key &quot;old&quot; to &quot;new&quot;.</span>

<span class="sd">        :param handler: exception handler</span>
<span class="sd">        :param kw: list of renames</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">rename</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">handler</span><span class="p">,</span> <span class="n">_kwa</span><span class="o">=</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">map_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">reraise_exception</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Map the fields of a dictionary.</span>

<span class="sd">        :param handler: exeption handler</span>
<span class="sd">        :param kw: list of key=function mappers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">map_dict</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">handler</span><span class="p">,</span> <span class="n">_kwa</span><span class="o">=</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select samples matching some predicate.</span>

<span class="sd">        :param predicate: predicate used to select samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">select</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">_kwa</span><span class="o">=</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">reraise_exception</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a dictionary-based sample to a tuple.</span>

<span class="sd">        Field names to be extracted can be specified as a Python list</span>
<span class="sd">        or as a string. &quot;__key__ jpg;png cls&quot; will extract a triple, with the</span>
<span class="sd">        first entry being the key, the second being a JPEG or PNG image, and</span>
<span class="sd">        the third being the contents of the cls file.</span>

<span class="sd">        :param args: field names</span>
<span class="sd">        :param handler: exception handler</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">handler</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">map_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">reraise_exception</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Map a tuple.</span>

<span class="sd">        :param args: List of functions corresponding to the fields of the tuple.</span>
<span class="sd">        :param handler: exception handler</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">map_tuple</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">handler</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dbcache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cache training samples in an SQLite database.</span>

<span class="sd">        This is useful for testing and for running validation tests.</span>

<span class="sd">        :param fname: filename for the sqlite database</span>
<span class="sd">        :param size: number of samples to be cached</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">dbcache</span><span class="o">.</span><span class="n">DBCache</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">associate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">associator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Slice the stream of training samples.</span>

<span class="sd">        Associates information from the associator with the current sample.</span>
<span class="sd">        The associator should either be a function or a hash table. It is</span>
<span class="sd">        invoked with the sample key as an argument and must return a dictionary</span>
<span class="sd">        of information that is merged with the sample.</span>

<span class="sd">        :param associator: callable or dictionary-like object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">associate</span><span class="p">,</span> <span class="n">associator</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Slice the stream of training samples.</span>

<span class="sd">        This takes the usual islice arguments of ([start], stop, [step])</span>

<span class="sd">        :param args: arguments to itertools.islice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">itt</span><span class="o">.</span><span class="n">islice</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rsample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Randomly subsample a stream of samples.</span>

<span class="sd">        :param args: probability of including a sample in the output stream.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">rsample</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nepochs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nbatches</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">batchsize</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">guess_batchsize</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Repeat samples from the source dataset iterator.</span>

<span class="sd">        With no arguments, repeat infinitely.</span>

<span class="sd">        :param nepochs: maximum number of epochs</span>
<span class="sd">        :param nbatches: maximum number of batches</span>
<span class="sd">        :param nsamples: maximum number of samples</span>
<span class="sd">        :param batchsize: integer giving batchsize, or function to compute it</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span>
            <span class="n">Repeatedly</span><span class="p">,</span>
            <span class="n">nepochs</span><span class="o">=</span><span class="n">nepochs</span><span class="p">,</span>
            <span class="n">nbatches</span><span class="o">=</span><span class="n">nbatches</span><span class="p">,</span>
            <span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span>
            <span class="n">batchsize</span><span class="o">=</span><span class="n">batchsize</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">checker</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mock_sample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mock_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mock</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A quick and simple way of switching to a mock dataset at the end of a pipeline.</span>

<span class="sd">        Use with `loader = loader.test(mock_sample=..., mock_length=...)</span>
<span class="sd">        You can turn on mocking with `loader.mock = True`</span>

<span class="sd">        :param length: length of the dataset</span>
<span class="sd">        :param checker: any kind of final checking function you want to run over samples</span>
<span class="sd">        :param mock_sample: mock sample</span>
<span class="sd">        :param mock_length: size of mocked dataset</span>
<span class="sd">        :param mock: turning mocking on/off</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span>
            <span class="n">DatasetTest</span><span class="p">,</span>
            <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
            <span class="n">checker</span><span class="o">=</span><span class="n">checker</span><span class="p">,</span>
            <span class="n">mock_sample</span><span class="o">=</span><span class="n">mock_sample</span><span class="p">,</span>
            <span class="n">mock_length</span><span class="o">=</span><span class="n">mock_length</span><span class="p">,</span>
            <span class="n">mock</span><span class="o">=</span><span class="n">mock</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">ddp_equalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equalize number of training samples in DistributedDataParallel training.</span>

<span class="sd">        Torch&#39;s DistributedDataParallel requires the same number of samples in</span>
<span class="sd">        all participating compute nodes.</span>

<span class="sd">        Use with `loader = loader.ddp_equalize(number_of_batches)`</span>


<span class="sd">        You need to specify the number of batches you want to equalize to.</span>
<span class="sd">        This is usually the number of samples in the dataset divided by the batch size.</span>

<span class="sd">        :param length: number of batches in the dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">torch.distributed</span>

        <span class="n">world_size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">distributed</span><span class="o">.</span><span class="n">is_initialized</span><span class="p">():</span>
            <span class="n">world_size</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">distributed</span><span class="o">.</span><span class="n">get_world_size</span><span class="p">()</span>
        <span class="n">numbatches</span> <span class="o">=</span> <span class="n">length</span> <span class="o">//</span> <span class="n">world_size</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">999999999</span><span class="p">)</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">numbatches</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">numbatches</span>
        <span class="k">return</span> <span class="n">result</span>


<span class="k">class</span> <span class="nc">Repeatedly</span><span class="p">(</span><span class="n">IterableDataset</span><span class="p">,</span> <span class="n">Composable</span><span class="p">,</span> <span class="n">Shorthands</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Repeatedly yield samples from a dataset.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nepochs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nbatches</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batchsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an instance of Repeatedly.</span>

<span class="sd">        :param nepochs: repeat for a maximum of nepochs</span>
<span class="sd">        :param nbatches: repeat for a maximum of nbatches</span>
<span class="sd">        :param nsamples: repeat for a maximum of nsamples (requires batchsize)</span>
<span class="sd">        :param batchsize: integer or function of sample returning batch size</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nepochs</span> <span class="o">=</span> <span class="n">nepochs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbatches</span> <span class="o">=</span> <span class="n">nbatches</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batchsize</span> <span class="o">=</span> <span class="n">batchsize</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator that iterates repeatedly over a source.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">repeatedly</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">nepochs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nepochs</span><span class="p">,</span> <span class="n">nbatches</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nbatches</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">batchsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batchsize</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the length of the source.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nepochs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nepochs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbatches</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbatches</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can&#39;t compute size for nsamples; please specify with length= argument&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Processor</span><span class="p">(</span><span class="n">IterableDataset</span><span class="p">,</span> <span class="n">Composable</span><span class="p">,</span> <span class="n">Shorthands</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class that turns a function into an IterableDataset.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">_kwa</span><span class="o">=</span><span class="p">{},</span> <span class="n">length</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a processor.</span>

<span class="sd">        The function should take an iterator as an argument and yield</span>
<span class="sd">        processed samples. The function is invoked as `f(source, *args, **kw)`.</span>

<span class="sd">        The `length` can be specified as `True`, in which case the value</span>
<span class="sd">        is taken from the source dataset, as a callable, in which case</span>
<span class="sd">        the length is the result of applying the callable to the source</span>
<span class="sd">        dataset, or as an integer, in which case the length returned by</span>
<span class="sd">        `__len__` is that integer.</span>

<span class="sd">        :param source: source dataset, an IterableDataset</span>
<span class="sd">        :param f: function implementing the processor</span>
<span class="sd">        :param args: extra arguments to the processor after the source iterator</span>
<span class="sd">        :param _kwa: keyword arguments</span>
<span class="sd">        :param length: specified length for the output</span>
<span class="sd">        :param kw: extra keyword arguments</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">_kwa</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>

    <span class="k">def</span> <span class="nf">source_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the source dataset.</span>

<span class="sd">        :param source: source dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator over the source dataset processed by the given function.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;must set source before calling iter </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">),</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the length of this dataset; see above how this is computed.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="si">}</span><span class="s2">: not a valid length specification&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">WebDataset</span><span class="p">(</span>
    <span class="n">urls</span><span class="p">,</span>
    <span class="n">shardshuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">cache_dir</span><span class="o">=</span><span class="n">default_cache_dir</span><span class="p">,</span>
    <span class="n">cache_size</span><span class="o">=</span><span class="n">default_cache_size</span><span class="p">,</span>
    <span class="n">cache_name</span><span class="o">=</span><span class="n">default_cache_name</span><span class="p">,</span>
    <span class="n">cache_verbose</span><span class="o">=</span><span class="n">default_cache_verbose</span><span class="p">,</span>
    <span class="n">splitter</span><span class="o">=</span><span class="n">split_by_worker</span><span class="p">,</span>
    <span class="n">nodesplitter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">handler</span><span class="o">=</span><span class="n">reraise_exception</span><span class="p">,</span>
    <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">warn_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a pipeline for WebDataset-style data files.</span>

<span class="sd">    This is a convenience function for constructing a partial pipeline</span>
<span class="sd">    that reads from a set of sharded tar files, extracts the individual</span>
<span class="sd">    files, and groups them together into samples (dictionaries).</span>

<span class="sd">    You can use all the methods from `Composable` (`then`, `compose`) and</span>
<span class="sd">    from `Shorthands` (`batched`, `unbatched`, `decode`, `shuffle`, etc.)</span>
<span class="sd">    on the result.</span>

<span class="sd">    :param urls: the source URLs, specified either as a list or as a brace-expanded string</span>
<span class="sd">    :param shardshuffle: boolean indicating whether the shards should be shuffled or not</span>
<span class="sd">    :param splitter: a function called for splitting shards among workers (True: PyTorch default, None: no splitting)</span>
<span class="sd">    :param nodesplitter: a function called for splitting shards among nodes (True: PyTorch default, None: no splitting)</span>
<span class="sd">    :param handler: an error handler</span>
<span class="sd">    :param length: the length of this dataset, should be an integer</span>
<span class="sd">    :param cache_dir: when set, caches shards in this directory</span>
<span class="sd">    :param cache_size: when set, specifies a maximum size for the shard cache</span>
<span class="sd">    :param cache_name: when set, specifies how shards should be named in the cache</span>
<span class="sd">    :param cache_verbose: when set, prints information about caching</span>
<span class="sd">    :param warn_empty: warn when no samples are generated at all</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">ShardList</span><span class="p">(</span>
        <span class="n">urls</span><span class="p">,</span>
        <span class="n">shuffle</span><span class="o">=</span><span class="n">shardshuffle</span><span class="p">,</span>
        <span class="n">splitter</span><span class="o">=</span><span class="n">splitter</span><span class="p">,</span>
        <span class="n">nodesplitter</span><span class="o">=</span><span class="n">nodesplitter</span><span class="p">,</span>
        <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">tariterators</span><span class="o">.</span><span class="n">url_opener</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">handler</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cache_dir</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">then</span><span class="p">(</span>
            <span class="n">shardcache</span><span class="o">.</span><span class="n">cache_shards</span><span class="p">,</span>
            <span class="n">cache_dir</span><span class="o">=</span><span class="n">cache_dir</span><span class="p">,</span>
            <span class="n">cache_size</span><span class="o">=</span><span class="n">cache_size</span><span class="p">,</span>
            <span class="n">cache_name</span><span class="o">=</span><span class="n">cache_name</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">cache_verbose</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">tariterators</span><span class="o">.</span><span class="n">tar_file_expander</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">handler</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">tariterators</span><span class="o">.</span><span class="n">group_by_keys</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">warn_empty</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">warn_no_samples</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">WebLoader</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a small wrapper around torch.utils.data.DataLoader.</span>

<span class="sd">    This wrapper works identically to the original `DataLoader`, but adds</span>
<span class="sd">    alls the convenience functions and filters for WebDataset.</span>

<span class="sd">    You can use all the methods from `Composable` (`then`, `compose`) and</span>
<span class="sd">    from `Shorthands` (`batched`, `unbatched`, `decode`, `shuffle`, etc.)</span>
<span class="sd">    on the result.</span>

<span class="sd">    :param args: forwarded to `DataLoader`</span>
<span class="sd">    :param kw: forwarded to `DataLoader`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Processor</span><span class="p">(</span><span class="n">DataLoader</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">),</span> <span class="n">utils</span><span class="o">.</span><span class="n">identity</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">DatasetTest</span><span class="p">(</span><span class="n">IterableDataset</span><span class="p">,</span> <span class="n">Composable</span><span class="p">,</span> <span class="n">Shorthands</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform final checks on an IterableDataset and permit easy mock tests.</span>

<span class="sd">    This is the implementation of the `Shorthands.test` method; you usually</span>
<span class="sd">    do not need to construct it explicitly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">checker</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mock_sample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mock_length</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">mock</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a DatasetTest.</span>

<span class="sd">        :param length: length of the dataset</span>
<span class="sd">        :param checker: any kind of final checking function you want to run over samples</span>
<span class="sd">        :param mock_sample: mock sample</span>
<span class="sd">        :param mock_length: size of mocked dataset</span>
<span class="sd">        :param mock: turning mocking on/off</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checker</span> <span class="o">=</span> <span class="n">checker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mock</span> <span class="o">=</span> <span class="n">mock</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mock_length</span> <span class="o">=</span> <span class="n">mock_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mock_sample</span> <span class="o">=</span> <span class="n">mock_sample</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the length of the test object.</span>

<span class="sd">        This is either the length of the mock object when in mock mode,</span>
<span class="sd">        otherwise the length of the underlying dataset/data loader.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mock</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mock_length</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="si">}</span><span class="s2">: not a valid length specification&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator either over the mock object or the underlying dataset.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mock</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mock_sample</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mock_length</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">mock_sample</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mock_sample</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">checker</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">checker</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">sample</span>


<span class="k">class</span> <span class="nc">ChoppedDataset</span><span class="p">(</span><span class="n">IterableDataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Change the actual and nominal length of an IterableDataset.</span>

<span class="sd">    This will continuously iterate through the original dataset, but</span>
<span class="sd">    impose new epoch boundaries at the given length/nominal.</span>
<span class="sd">    This exists mainly as a workaround for the odd logic in DataLoader.</span>
<span class="sd">    It is also useful for choosing smaller nominal epoch sizes with</span>
<span class="sd">    very large datasets.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nominal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a ChoppedDataset.</span>

<span class="sd">        :param dataset: IterableDataset</span>
<span class="sd">        :param length: declared length of the dataset</span>
<span class="sd">        :param nominal: nominal length of dataset (if different from declared)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span>
        <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nominal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="k">if</span> <span class="n">nominal</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">nominal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the length of the dataset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nominal</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the pickled state of the dataset.</span>

<span class="sd">        This resets the dataset iterator, since that can&#39;t be pickled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator over the dataset.</span>

<span class="sd">        This iterator returns as many samples as given by the `length` parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">sample</span>


<span class="n">ResizedDataset</span> <span class="o">=</span> <span class="n">ChoppedDataset</span>
</pre></div>

        </details>

            </section>
                <section id="MockDataset">
                                <div class="attr class">
        <a class="headerlink" href="#MockDataset">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">MockDataset</span><wbr>(<span class="base">torch.utils.data.dataset.Dataset[+T_co]</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">MockDataset</span><span class="p">(</span><span class="n">IterableDataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;MockDataset.</span>

<span class="sd">    A mock dataset for performance testing and unit testing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a mock dataset instance.</span>

<span class="sd">        :param sample: the sample to be returned repeatedly</span>
<span class="sd">        :param length: the length of the mock dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span> <span class="n">sample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the length of this mock dataset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator over this mock dataset.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample</span>
</pre></div>

        </details>

            <div class="docstring"><p>MockDataset.</p>

<p>A mock dataset for performance testing and unit testing.</p>
</div>


                            <div id="MockDataset.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#MockDataset.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">MockDataset</span><span class="signature">(sample, length)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a mock dataset instance.</span>

<span class="sd">        :param sample: the sample to be returned repeatedly</span>
<span class="sd">        :param length: the length of the mock dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span> <span class="n">sample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create a mock dataset instance.</p>

<p>:param sample: the sample to be returned repeatedly
:param length: the length of the mock dataset</p>
</div>


                            </div>
                </section>
                <section id="warn_no_samples">
                            <div class="attr function"><a class="headerlink" href="#warn_no_samples">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">warn_no_samples</span><span class="signature">(data)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">warn_no_samples</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Warn if the iterator yields no samples.&quot;&quot;&quot;</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">sample</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">env</span> <span class="o">=</span> <span class="n">get_worker_environment</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">env</span><span class="o">.</span><span class="n">rank</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;no samples at all in node </span><span class="si">{</span><span class="n">env</span><span class="o">.</span><span class="n">rank</span><span class="si">}</span><span class="s2">, worker </span><span class="si">{</span><span class="n">env</span><span class="o">.</span><span class="n">worker</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Warn if the iterator yields no samples.</p>
</div>


                </section>
                <section id="Composable">
                                <div class="attr class">
        <a class="headerlink" href="#Composable">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Composable</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Composable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A mixin implementing composability of data pipelines.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the composable mixin.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">source_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the source for this dataset.</span>

<span class="sd">        :param source: source dataset, should be an IterableDataset instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">then</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compose this processor with a new processor defined by a function.</span>

<span class="sd">        The function is of the form:</span>

<span class="sd">            def my_process(source, ...):</span>
<span class="sd">                for sample in source:</span>
<span class="sd">                    ...</span>
<span class="sd">                    result = ...</span>
<span class="sd">                    yield result</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">assert</span> <span class="s2">&quot;source&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span>
        <span class="c1"># print(&quot;Processor&quot;, args, kw)</span>
        <span class="k">return</span> <span class="n">Processor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constructor</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compose this processor with another IterableDataset.</span>

<span class="sd">        The constructor should be of the form `__init__(self, source_dataset, ...)`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">constructor</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">constructor</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span><span class="o">.</span><span class="n">source_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>A mixin implementing composability of data pipelines.</p>
</div>


                            <div id="Composable.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Composable.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Composable</span><span class="signature">()</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the composable mixin.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Initialize the composable mixin.</p>
</div>


                            </div>
                            <div id="Composable.source_" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Composable.source_">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">source_</span><span class="signature">(self, source)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">source_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the source for this dataset.</span>

<span class="sd">        :param source: source dataset, should be an IterableDataset instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="k">return</span> <span class="bp">self</span>
</pre></div>

        </details>

            <div class="docstring"><p>Set the source for this dataset.</p>

<p>:param source: source dataset, should be an IterableDataset instance</p>
</div>


                            </div>
                            <div id="Composable.then" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Composable.then">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">then</span><span class="signature">(self, f, *args, length=True, **kw)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">then</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compose this processor with a new processor defined by a function.</span>

<span class="sd">        The function is of the form:</span>

<span class="sd">            def my_process(source, ...):</span>
<span class="sd">                for sample in source:</span>
<span class="sd">                    ...</span>
<span class="sd">                    result = ...</span>
<span class="sd">                    yield result</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">assert</span> <span class="s2">&quot;source&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span>
        <span class="c1"># print(&quot;Processor&quot;, args, kw)</span>
        <span class="k">return</span> <span class="n">Processor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Compose this processor with a new processor defined by a function.</p>

<p>The function is of the form:</p>

<pre><code>def my_process(source, ...):
    for sample in source:
        ...
        result = ...
        yield result
</code></pre>
</div>


                            </div>
                            <div id="Composable.compose" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Composable.compose">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">compose</span><span class="signature">(self, constructor, *args, **kw)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">compose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constructor</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compose this processor with another IterableDataset.</span>

<span class="sd">        The constructor should be of the form `__init__(self, source_dataset, ...)`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">constructor</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">constructor</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span><span class="o">.</span><span class="n">source_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Compose this processor with another IterableDataset.</p>

<p>The constructor should be of the form <code>__init__(self, source_dataset, ...)</code></p>
</div>


                            </div>
                </section>
                <section id="ShardList">
                                <div class="attr class">
        <a class="headerlink" href="#ShardList">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">ShardList</span><wbr>(<span class="base">torch.utils.data.dataset.Dataset[+T_co]</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">ShardList</span><span class="p">(</span><span class="n">IterableDataset</span><span class="p">,</span> <span class="n">Composable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An iterable dataset yielding a list of urls.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">urls</span><span class="p">,</span>
        <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">nodesplitter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">splitter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a ShardList.</span>

<span class="sd">        :param urls: a list of URLs as a Python list or brace notation string</span>
<span class="sd">        :param shuffle: whether to shuffle the URLs</span>
<span class="sd">        :param nodesplitter: function for splitting urls across nodes (None: don&#39;t split)</span>
<span class="sd">        :param splitter: function for splitting urls across workers (None: don&#39;t split)</span>
<span class="sd">        :param length: user-specified length; this is returned unchanged by the len() function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span> <span class="o">=</span> <span class="n">shuffle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="k">if</span> <span class="n">nodesplitter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodesplitter</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">identity</span>
        <span class="k">elif</span> <span class="n">nodesplitter</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodesplitter</span> <span class="o">=</span> <span class="n">split_by_node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">nodesplitter</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodesplitter</span> <span class="o">=</span> <span class="n">nodesplitter</span>
        <span class="k">if</span> <span class="n">splitter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">splitter</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">identity</span>
        <span class="k">elif</span> <span class="n">splitter</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">splitter</span> <span class="o">=</span> <span class="n">split_by_worker</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">splitter</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">splitter</span> <span class="o">=</span> <span class="n">splitter</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">urls</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">urls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">braceexpand</span><span class="o">.</span><span class="n">braceexpand</span><span class="p">(</span><span class="n">urls</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">urls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">urls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">urls</span> <span class="o">=</span> <span class="n">urls</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">urls</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator over the shards.&quot;&quot;&quot;</span>
        <span class="n">urls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">urls</span><span class="p">)</span>
        <span class="n">urls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodesplitter</span><span class="p">(</span><span class="n">urls</span><span class="p">))</span>
        <span class="n">urls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splitter</span><span class="p">(</span><span class="n">urls</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">urls</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="p">:</span>
            <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">urls</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">:</span>
            <span class="k">yield</span> <span class="nb">dict</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the user-specified length of this dataset.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;length requested, but no length specified for ShardIterator&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
</pre></div>

        </details>

            <div class="docstring"><p>An iterable dataset yielding a list of urls.</p>
</div>


                            <div id="ShardList.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#ShardList.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">ShardList</span><span class="signature">(urls, shuffle=False, nodesplitter=True, splitter=True, length=None)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">urls</span><span class="p">,</span>
        <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">nodesplitter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">splitter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a ShardList.</span>

<span class="sd">        :param urls: a list of URLs as a Python list or brace notation string</span>
<span class="sd">        :param shuffle: whether to shuffle the URLs</span>
<span class="sd">        :param nodesplitter: function for splitting urls across nodes (None: don&#39;t split)</span>
<span class="sd">        :param splitter: function for splitting urls across workers (None: don&#39;t split)</span>
<span class="sd">        :param length: user-specified length; this is returned unchanged by the len() function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span> <span class="o">=</span> <span class="n">shuffle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="k">if</span> <span class="n">nodesplitter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodesplitter</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">identity</span>
        <span class="k">elif</span> <span class="n">nodesplitter</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodesplitter</span> <span class="o">=</span> <span class="n">split_by_node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">nodesplitter</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodesplitter</span> <span class="o">=</span> <span class="n">nodesplitter</span>
        <span class="k">if</span> <span class="n">splitter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">splitter</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">identity</span>
        <span class="k">elif</span> <span class="n">splitter</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">splitter</span> <span class="o">=</span> <span class="n">split_by_worker</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">splitter</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">splitter</span> <span class="o">=</span> <span class="n">splitter</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">urls</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">urls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">braceexpand</span><span class="o">.</span><span class="n">braceexpand</span><span class="p">(</span><span class="n">urls</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">urls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">urls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">urls</span> <span class="o">=</span> <span class="n">urls</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">urls</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create a ShardList.</p>

<p>:param urls: a list of URLs as a Python list or brace notation string
:param shuffle: whether to shuffle the URLs
:param nodesplitter: function for splitting urls across nodes (None: don't split)
:param splitter: function for splitting urls across workers (None: don't split)
:param length: user-specified length; this is returned unchanged by the len() function</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Composable">Composable</a></dt>
                                <dd id="ShardList.source_" class="function"><a href="#Composable.source_">source_</a></dd>
                <dd id="ShardList.then" class="function"><a href="#Composable.then">then</a></dd>
                <dd id="ShardList.compose" class="function"><a href="#Composable.compose">compose</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="BatchedLength">
                                <div class="attr class">
        <a class="headerlink" href="#BatchedLength">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">BatchedLength</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">BatchedLength</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute the batched length of a dataset.</span>

<span class="sd">    We make this a class rather than a closure so that it can be pickled.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batchsize</span><span class="p">,</span> <span class="n">partial</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize.</span>

<span class="sd">        :param batchsize: batch size</span>
<span class="sd">        :param partial: allow partial batches</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batchsize</span> <span class="o">=</span> <span class="n">batchsize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">partial</span> <span class="o">=</span> <span class="n">partial</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the number of batches for the given length.</span>

<span class="sd">        :param length: number of samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Add +1 when partial batch is allowed</span>
        <span class="n">partial_batch</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">length</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">batchsize</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="c1"># True or False</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">length</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">batchsize</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">partial</span> <span class="ow">and</span> <span class="n">partial_batch</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Compute the batched length of a dataset.</p>

<p>We make this a class rather than a closure so that it can be pickled.</p>
</div>


                            <div id="BatchedLength.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BatchedLength.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">BatchedLength</span><span class="signature">(batchsize, partial: bool)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batchsize</span><span class="p">,</span> <span class="n">partial</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize.</span>

<span class="sd">        :param batchsize: batch size</span>
<span class="sd">        :param partial: allow partial batches</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batchsize</span> <span class="o">=</span> <span class="n">batchsize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">partial</span> <span class="o">=</span> <span class="n">partial</span>
</pre></div>

        </details>

            <div class="docstring"><p>Initialize.</p>

<p>:param batchsize: batch size
:param partial: allow partial batches</p>
</div>


                            </div>
                </section>
                <section id="Shorthands">
                                <div class="attr class">
        <a class="headerlink" href="#Shorthands">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Shorthands</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Shorthands</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A convenient set of shorthands for common data transformations.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">batched</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batchsize</span><span class="p">,</span> <span class="n">collation_fn</span><span class="o">=</span><span class="n">iterators</span><span class="o">.</span><span class="n">default_collation_fn</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute batches for the given dataset.</span>

<span class="sd">        :param batchsize: desired batchsize</span>
<span class="sd">        :param collation_fn: collation function to turn list of objects into batches</span>
<span class="sd">        :param partial: return partial batches</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">BatchedLength</span><span class="p">(</span><span class="n">batchsize</span><span class="p">,</span> <span class="n">partial</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span>
            <span class="n">iterators</span><span class="o">.</span><span class="n">batched</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="n">batchsize</span><span class="o">=</span><span class="n">batchsize</span><span class="p">,</span> <span class="n">collation_fn</span><span class="o">=</span><span class="n">collation_fn</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="n">partial</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Take a stream of batches and turn it back into a stream of samples.</span>

<span class="sd">        :param length: user-supplied length for the unbatched dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">unbatched</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shuffle the dataset using an internal shuffle buffer.</span>

<span class="sd">        This will buffer up `initial` samples. Then it will add new samples to</span>
<span class="sd">        the internal buffer and return random samples from the buffer, simultaneously</span>
<span class="sd">        filling up the buffer to the given size.</span>

<span class="sd">        Using initial &lt; size will result in less initial randomness but faster</span>
<span class="sd">        startups.</span>

<span class="sd">        :param size: size of the shuffle buffer</span>
<span class="sd">        :param initial: buffer this many samples before yield training samples</span>
<span class="sd">        :param handler: The exception handling strategy.</span>
<span class="sd">        :param kw: other keywords for iterators.shuffle</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">shuffle</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">reraise_exception</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Map a function over a stream of samples.</span>

<span class="sd">        This may be a tuple stream or a stream of dicts.</span>

<span class="sd">        :param f: The function to be mapped.</span>
<span class="sd">        :param handler: The exception handling strategy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">map</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">handler</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">pre</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">post</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">handler</span><span class="o">=</span><span class="n">reraise_exception</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Decode samples.</span>

<span class="sd">        This is a special form of mapping over samples given as dicts.</span>
<span class="sd">        A list of all decoders is formed from `pre + args + post`.</span>
<span class="sd">        For each dict entry, the decoders on that list are invoked in sequence</span>
<span class="sd">        until one of them decodes the sample. That decoded value is then stored</span>
<span class="sd">        in the dictionary and the next dictionary entry is decoded.</span>

<span class="sd">        The `pre` and `post` decoder lists are set to common defaults (including `.gz` decoding).</span>
<span class="sd">        You can specify decoders for your application in the `args` argument.</span>
<span class="sd">        String arguments like &quot;pil&quot; are a shorthand for image decoder functions like</span>
<span class="sd">        `webdataset.imagehandler(&quot;pil&quot;)`. All other decoders must be specified as</span>
<span class="sd">        functions.</span>

<span class="sd">        :param args: list of decoder functions; a string like &quot;pil&quot; is a shorthand for common image decoders</span>
<span class="sd">        :param pre: a list of decoder functions that is always carried out before args</span>
<span class="sd">        :param post: a list of decoder functions that is always carried out after args</span>
<span class="sd">        :param only: limit decoding to the list of these fields</span>
<span class="sd">        :param handler: exception handler</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># for backwards compatibility</span>
        <span class="n">handlers</span> <span class="o">=</span> <span class="p">[</span><span class="n">autodecode</span><span class="o">.</span><span class="n">ImageHandler</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">h</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
        <span class="n">decoder</span> <span class="o">=</span> <span class="n">autodecode</span><span class="o">.</span><span class="n">Decoder</span><span class="p">(</span><span class="n">handlers</span><span class="p">,</span> <span class="n">pre</span><span class="o">=</span><span class="n">pre</span><span class="p">,</span> <span class="n">post</span><span class="o">=</span><span class="n">post</span><span class="p">,</span> <span class="n">only</span><span class="o">=</span><span class="n">only</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">decoder</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">handler</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">reraise_exception</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rename fields in a dictionary based sample.</span>

<span class="sd">        This works on dictionary input streams. A keyword argument like</span>
<span class="sd">        `new=&quot;old&quot;` renames extension/key &quot;old&quot; to &quot;new&quot;.</span>

<span class="sd">        :param handler: exception handler</span>
<span class="sd">        :param kw: list of renames</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">rename</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">handler</span><span class="p">,</span> <span class="n">_kwa</span><span class="o">=</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">map_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">reraise_exception</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Map the fields of a dictionary.</span>

<span class="sd">        :param handler: exeption handler</span>
<span class="sd">        :param kw: list of key=function mappers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">map_dict</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">handler</span><span class="p">,</span> <span class="n">_kwa</span><span class="o">=</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select samples matching some predicate.</span>

<span class="sd">        :param predicate: predicate used to select samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">select</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">_kwa</span><span class="o">=</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">reraise_exception</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a dictionary-based sample to a tuple.</span>

<span class="sd">        Field names to be extracted can be specified as a Python list</span>
<span class="sd">        or as a string. &quot;__key__ jpg;png cls&quot; will extract a triple, with the</span>
<span class="sd">        first entry being the key, the second being a JPEG or PNG image, and</span>
<span class="sd">        the third being the contents of the cls file.</span>

<span class="sd">        :param args: field names</span>
<span class="sd">        :param handler: exception handler</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">handler</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">map_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">reraise_exception</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Map a tuple.</span>

<span class="sd">        :param args: List of functions corresponding to the fields of the tuple.</span>
<span class="sd">        :param handler: exception handler</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">map_tuple</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">handler</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dbcache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cache training samples in an SQLite database.</span>

<span class="sd">        This is useful for testing and for running validation tests.</span>

<span class="sd">        :param fname: filename for the sqlite database</span>
<span class="sd">        :param size: number of samples to be cached</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">dbcache</span><span class="o">.</span><span class="n">DBCache</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">associate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">associator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Slice the stream of training samples.</span>

<span class="sd">        Associates information from the associator with the current sample.</span>
<span class="sd">        The associator should either be a function or a hash table. It is</span>
<span class="sd">        invoked with the sample key as an argument and must return a dictionary</span>
<span class="sd">        of information that is merged with the sample.</span>

<span class="sd">        :param associator: callable or dictionary-like object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">associate</span><span class="p">,</span> <span class="n">associator</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Slice the stream of training samples.</span>

<span class="sd">        This takes the usual islice arguments of ([start], stop, [step])</span>

<span class="sd">        :param args: arguments to itertools.islice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">itt</span><span class="o">.</span><span class="n">islice</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rsample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Randomly subsample a stream of samples.</span>

<span class="sd">        :param args: probability of including a sample in the output stream.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">rsample</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nepochs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nbatches</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">batchsize</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">guess_batchsize</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Repeat samples from the source dataset iterator.</span>

<span class="sd">        With no arguments, repeat infinitely.</span>

<span class="sd">        :param nepochs: maximum number of epochs</span>
<span class="sd">        :param nbatches: maximum number of batches</span>
<span class="sd">        :param nsamples: maximum number of samples</span>
<span class="sd">        :param batchsize: integer giving batchsize, or function to compute it</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span>
            <span class="n">Repeatedly</span><span class="p">,</span>
            <span class="n">nepochs</span><span class="o">=</span><span class="n">nepochs</span><span class="p">,</span>
            <span class="n">nbatches</span><span class="o">=</span><span class="n">nbatches</span><span class="p">,</span>
            <span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span>
            <span class="n">batchsize</span><span class="o">=</span><span class="n">batchsize</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">checker</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mock_sample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mock_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mock</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A quick and simple way of switching to a mock dataset at the end of a pipeline.</span>

<span class="sd">        Use with `loader = loader.test(mock_sample=..., mock_length=...)</span>
<span class="sd">        You can turn on mocking with `loader.mock = True`</span>

<span class="sd">        :param length: length of the dataset</span>
<span class="sd">        :param checker: any kind of final checking function you want to run over samples</span>
<span class="sd">        :param mock_sample: mock sample</span>
<span class="sd">        :param mock_length: size of mocked dataset</span>
<span class="sd">        :param mock: turning mocking on/off</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span>
            <span class="n">DatasetTest</span><span class="p">,</span>
            <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
            <span class="n">checker</span><span class="o">=</span><span class="n">checker</span><span class="p">,</span>
            <span class="n">mock_sample</span><span class="o">=</span><span class="n">mock_sample</span><span class="p">,</span>
            <span class="n">mock_length</span><span class="o">=</span><span class="n">mock_length</span><span class="p">,</span>
            <span class="n">mock</span><span class="o">=</span><span class="n">mock</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">ddp_equalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equalize number of training samples in DistributedDataParallel training.</span>

<span class="sd">        Torch&#39;s DistributedDataParallel requires the same number of samples in</span>
<span class="sd">        all participating compute nodes.</span>

<span class="sd">        Use with `loader = loader.ddp_equalize(number_of_batches)`</span>


<span class="sd">        You need to specify the number of batches you want to equalize to.</span>
<span class="sd">        This is usually the number of samples in the dataset divided by the batch size.</span>

<span class="sd">        :param length: number of batches in the dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">torch.distributed</span>

        <span class="n">world_size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">distributed</span><span class="o">.</span><span class="n">is_initialized</span><span class="p">():</span>
            <span class="n">world_size</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">distributed</span><span class="o">.</span><span class="n">get_world_size</span><span class="p">()</span>
        <span class="n">numbatches</span> <span class="o">=</span> <span class="n">length</span> <span class="o">//</span> <span class="n">world_size</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">999999999</span><span class="p">)</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">numbatches</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">numbatches</span>
        <span class="k">return</span> <span class="n">result</span>
</pre></div>

        </details>

            <div class="docstring"><p>A convenient set of shorthands for common data transformations.</p>
</div>


                            <div id="Shorthands.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Shorthands.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Shorthands</span><span class="signature">()</span>
    </div>

        
    

                            </div>
                            <div id="Shorthands.batched" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Shorthands.batched">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">batched</span><span class="signature">(
    self,
    batchsize,
    collation_fn=&lt;function default_collation_fn&gt;,
    partial=True
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">batched</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batchsize</span><span class="p">,</span> <span class="n">collation_fn</span><span class="o">=</span><span class="n">iterators</span><span class="o">.</span><span class="n">default_collation_fn</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute batches for the given dataset.</span>

<span class="sd">        :param batchsize: desired batchsize</span>
<span class="sd">        :param collation_fn: collation function to turn list of objects into batches</span>
<span class="sd">        :param partial: return partial batches</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">BatchedLength</span><span class="p">(</span><span class="n">batchsize</span><span class="p">,</span> <span class="n">partial</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span>
            <span class="n">iterators</span><span class="o">.</span><span class="n">batched</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="n">batchsize</span><span class="o">=</span><span class="n">batchsize</span><span class="p">,</span> <span class="n">collation_fn</span><span class="o">=</span><span class="n">collation_fn</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="n">partial</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Compute batches for the given dataset.</p>

<p>:param batchsize: desired batchsize
:param collation_fn: collation function to turn list of objects into batches
:param partial: return partial batches</p>
</div>


                            </div>
                            <div id="Shorthands.unbatched" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Shorthands.unbatched">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">unbatched</span><span class="signature">(self, length=None)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Take a stream of batches and turn it back into a stream of samples.</span>

<span class="sd">        :param length: user-supplied length for the unbatched dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">unbatched</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Take a stream of batches and turn it back into a stream of samples.</p>

<p>:param length: user-supplied length for the unbatched dataset.</p>
</div>


                            </div>
                            <div id="Shorthands.shuffle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Shorthands.shuffle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">shuffle</span><span class="signature">(self, size, **kw)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shuffle the dataset using an internal shuffle buffer.</span>

<span class="sd">        This will buffer up `initial` samples. Then it will add new samples to</span>
<span class="sd">        the internal buffer and return random samples from the buffer, simultaneously</span>
<span class="sd">        filling up the buffer to the given size.</span>

<span class="sd">        Using initial &lt; size will result in less initial randomness but faster</span>
<span class="sd">        startups.</span>

<span class="sd">        :param size: size of the shuffle buffer</span>
<span class="sd">        :param initial: buffer this many samples before yield training samples</span>
<span class="sd">        :param handler: The exception handling strategy.</span>
<span class="sd">        :param kw: other keywords for iterators.shuffle</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">shuffle</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Shuffle the dataset using an internal shuffle buffer.</p>

<p>This will buffer up <code>initial</code> samples. Then it will add new samples to
the internal buffer and return random samples from the buffer, simultaneously
filling up the buffer to the given size.</p>

<p>Using initial &lt; size will result in less initial randomness but faster
startups.</p>

<p>:param size: size of the shuffle buffer
:param initial: buffer this many samples before yield training samples
:param handler: The exception handling strategy.
:param kw: other keywords for iterators.shuffle</p>
</div>


                            </div>
                            <div id="Shorthands.map" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Shorthands.map">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">map</span><span class="signature">(self, f, handler=&lt;function reraise_exception&gt;)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">reraise_exception</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Map a function over a stream of samples.</span>

<span class="sd">        This may be a tuple stream or a stream of dicts.</span>

<span class="sd">        :param f: The function to be mapped.</span>
<span class="sd">        :param handler: The exception handling strategy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">map</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">handler</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Map a function over a stream of samples.</p>

<p>This may be a tuple stream or a stream of dicts.</p>

<p>:param f: The function to be mapped.
:param handler: The exception handling strategy.</p>
</div>


                            </div>
                            <div id="Shorthands.decode" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Shorthands.decode">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">decode</span><span class="signature">(
    self,
    *args,
    pre=None,
    post=None,
    only=None,
    handler=&lt;function reraise_exception&gt;
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">pre</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">post</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">handler</span><span class="o">=</span><span class="n">reraise_exception</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Decode samples.</span>

<span class="sd">        This is a special form of mapping over samples given as dicts.</span>
<span class="sd">        A list of all decoders is formed from `pre + args + post`.</span>
<span class="sd">        For each dict entry, the decoders on that list are invoked in sequence</span>
<span class="sd">        until one of them decodes the sample. That decoded value is then stored</span>
<span class="sd">        in the dictionary and the next dictionary entry is decoded.</span>

<span class="sd">        The `pre` and `post` decoder lists are set to common defaults (including `.gz` decoding).</span>
<span class="sd">        You can specify decoders for your application in the `args` argument.</span>
<span class="sd">        String arguments like &quot;pil&quot; are a shorthand for image decoder functions like</span>
<span class="sd">        `webdataset.imagehandler(&quot;pil&quot;)`. All other decoders must be specified as</span>
<span class="sd">        functions.</span>

<span class="sd">        :param args: list of decoder functions; a string like &quot;pil&quot; is a shorthand for common image decoders</span>
<span class="sd">        :param pre: a list of decoder functions that is always carried out before args</span>
<span class="sd">        :param post: a list of decoder functions that is always carried out after args</span>
<span class="sd">        :param only: limit decoding to the list of these fields</span>
<span class="sd">        :param handler: exception handler</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># for backwards compatibility</span>
        <span class="n">handlers</span> <span class="o">=</span> <span class="p">[</span><span class="n">autodecode</span><span class="o">.</span><span class="n">ImageHandler</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">h</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
        <span class="n">decoder</span> <span class="o">=</span> <span class="n">autodecode</span><span class="o">.</span><span class="n">Decoder</span><span class="p">(</span><span class="n">handlers</span><span class="p">,</span> <span class="n">pre</span><span class="o">=</span><span class="n">pre</span><span class="p">,</span> <span class="n">post</span><span class="o">=</span><span class="n">post</span><span class="p">,</span> <span class="n">only</span><span class="o">=</span><span class="n">only</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">decoder</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">handler</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Decode samples.</p>

<p>This is a special form of mapping over samples given as dicts.
A list of all decoders is formed from <code>pre + args + post</code>.
For each dict entry, the decoders on that list are invoked in sequence
until one of them decodes the sample. That decoded value is then stored
in the dictionary and the next dictionary entry is decoded.</p>

<p>The <code>pre</code> and <code>post</code> decoder lists are set to common defaults (including <code>.gz</code> decoding).
You can specify decoders for your application in the <code>args</code> argument.
String arguments like "pil" are a shorthand for image decoder functions like
<code><a href="../webdataset.html#imagehandler">webdataset.imagehandler</a>("pil")</code>. All other decoders must be specified as
functions.</p>

<p>:param args: list of decoder functions; a string like "pil" is a shorthand for common image decoders
:param pre: a list of decoder functions that is always carried out before args
:param post: a list of decoder functions that is always carried out after args
:param only: limit decoding to the list of these fields
:param handler: exception handler</p>
</div>


                            </div>
                            <div id="Shorthands.rename" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Shorthands.rename">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">rename</span><span class="signature">(self, handler=&lt;function reraise_exception&gt;, **kw)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">reraise_exception</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rename fields in a dictionary based sample.</span>

<span class="sd">        This works on dictionary input streams. A keyword argument like</span>
<span class="sd">        `new=&quot;old&quot;` renames extension/key &quot;old&quot; to &quot;new&quot;.</span>

<span class="sd">        :param handler: exception handler</span>
<span class="sd">        :param kw: list of renames</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">rename</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">handler</span><span class="p">,</span> <span class="n">_kwa</span><span class="o">=</span><span class="n">kw</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Rename fields in a dictionary based sample.</p>

<p>This works on dictionary input streams. A keyword argument like
<code>new="old"</code> renames extension/key "old" to "new".</p>

<p>:param handler: exception handler
:param kw: list of renames</p>
</div>


                            </div>
                            <div id="Shorthands.map_dict" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Shorthands.map_dict">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">map_dict</span><span class="signature">(self, handler=&lt;function reraise_exception&gt;, **kw)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">map_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">reraise_exception</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Map the fields of a dictionary.</span>

<span class="sd">        :param handler: exeption handler</span>
<span class="sd">        :param kw: list of key=function mappers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">map_dict</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">handler</span><span class="p">,</span> <span class="n">_kwa</span><span class="o">=</span><span class="n">kw</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Map the fields of a dictionary.</p>

<p>:param handler: exeption handler
:param kw: list of key=function mappers</p>
</div>


                            </div>
                            <div id="Shorthands.select" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Shorthands.select">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">select</span><span class="signature">(self, predicate, **kw)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select samples matching some predicate.</span>

<span class="sd">        :param predicate: predicate used to select samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">select</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">_kwa</span><span class="o">=</span><span class="n">kw</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Select samples matching some predicate.</p>

<p>:param predicate: predicate used to select samples</p>
</div>


                            </div>
                            <div id="Shorthands.to_tuple" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Shorthands.to_tuple">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">to_tuple</span><span class="signature">(self, *args, handler=&lt;function reraise_exception&gt;)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">to_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">reraise_exception</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a dictionary-based sample to a tuple.</span>

<span class="sd">        Field names to be extracted can be specified as a Python list</span>
<span class="sd">        or as a string. &quot;__key__ jpg;png cls&quot; will extract a triple, with the</span>
<span class="sd">        first entry being the key, the second being a JPEG or PNG image, and</span>
<span class="sd">        the third being the contents of the cls file.</span>

<span class="sd">        :param args: field names</span>
<span class="sd">        :param handler: exception handler</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">handler</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Convert a dictionary-based sample to a tuple.</p>

<p>Field names to be extracted can be specified as a Python list
or as a string. "__key__ jpg;png cls" will extract a triple, with the
first entry being the key, the second being a JPEG or PNG image, and
the third being the contents of the cls file.</p>

<p>:param args: field names
:param handler: exception handler</p>
</div>


                            </div>
                            <div id="Shorthands.map_tuple" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Shorthands.map_tuple">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">map_tuple</span><span class="signature">(self, *args, handler=&lt;function reraise_exception&gt;)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">map_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">reraise_exception</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Map a tuple.</span>

<span class="sd">        :param args: List of functions corresponding to the fields of the tuple.</span>
<span class="sd">        :param handler: exception handler</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">map_tuple</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">handler</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Map a tuple.</p>

<p>:param args: List of functions corresponding to the fields of the tuple.
:param handler: exception handler</p>
</div>


                            </div>
                            <div id="Shorthands.dbcache" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Shorthands.dbcache">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">dbcache</span><span class="signature">(self, fname, size)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">dbcache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cache training samples in an SQLite database.</span>

<span class="sd">        This is useful for testing and for running validation tests.</span>

<span class="sd">        :param fname: filename for the sqlite database</span>
<span class="sd">        :param size: number of samples to be cached</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">dbcache</span><span class="o">.</span><span class="n">DBCache</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Cache training samples in an SQLite database.</p>

<p>This is useful for testing and for running validation tests.</p>

<p>:param fname: filename for the sqlite database
:param size: number of samples to be cached</p>
</div>


                            </div>
                            <div id="Shorthands.associate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Shorthands.associate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">associate</span><span class="signature">(self, associator)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">associate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">associator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Slice the stream of training samples.</span>

<span class="sd">        Associates information from the associator with the current sample.</span>
<span class="sd">        The associator should either be a function or a hash table. It is</span>
<span class="sd">        invoked with the sample key as an argument and must return a dictionary</span>
<span class="sd">        of information that is merged with the sample.</span>

<span class="sd">        :param associator: callable or dictionary-like object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">associate</span><span class="p">,</span> <span class="n">associator</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Slice the stream of training samples.</p>

<p>Associates information from the associator with the current sample.
The associator should either be a function or a hash table. It is
invoked with the sample key as an argument and must return a dictionary
of information that is merged with the sample.</p>

<p>:param associator: callable or dictionary-like object</p>
</div>


                            </div>
                            <div id="Shorthands.slice" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Shorthands.slice">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">slice</span><span class="signature">(self, *args)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Slice the stream of training samples.</span>

<span class="sd">        This takes the usual islice arguments of ([start], stop, [step])</span>

<span class="sd">        :param args: arguments to itertools.islice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">itt</span><span class="o">.</span><span class="n">islice</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Slice the stream of training samples.</p>

<p>This takes the usual islice arguments of ([start], stop, [step])</p>

<p>:param args: arguments to itertools.islice</p>
</div>


                            </div>
                            <div id="Shorthands.rsample" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Shorthands.rsample">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">rsample</span><span class="signature">(self, p=0.5)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">rsample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Randomly subsample a stream of samples.</span>

<span class="sd">        :param args: probability of including a sample in the output stream.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">iterators</span><span class="o">.</span><span class="n">rsample</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Randomly subsample a stream of samples.</p>

<p>:param args: probability of including a sample in the output stream.</p>
</div>


                            </div>
                            <div id="Shorthands.repeat" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Shorthands.repeat">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">repeat</span><span class="signature">(
    self,
    nepochs=None,
    nbatches=None,
    nsamples=None,
    batchsize=&lt;function guess_batchsize&gt;
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nepochs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nbatches</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">batchsize</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">guess_batchsize</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Repeat samples from the source dataset iterator.</span>

<span class="sd">        With no arguments, repeat infinitely.</span>

<span class="sd">        :param nepochs: maximum number of epochs</span>
<span class="sd">        :param nbatches: maximum number of batches</span>
<span class="sd">        :param nsamples: maximum number of samples</span>
<span class="sd">        :param batchsize: integer giving batchsize, or function to compute it</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span>
            <span class="n">Repeatedly</span><span class="p">,</span>
            <span class="n">nepochs</span><span class="o">=</span><span class="n">nepochs</span><span class="p">,</span>
            <span class="n">nbatches</span><span class="o">=</span><span class="n">nbatches</span><span class="p">,</span>
            <span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span>
            <span class="n">batchsize</span><span class="o">=</span><span class="n">batchsize</span><span class="p">,</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Repeat samples from the source dataset iterator.</p>

<p>With no arguments, repeat infinitely.</p>

<p>:param nepochs: maximum number of epochs
:param nbatches: maximum number of batches
:param nsamples: maximum number of samples
:param batchsize: integer giving batchsize, or function to compute it</p>
</div>


                            </div>
                            <div id="Shorthands.test" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Shorthands.test">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">test</span><span class="signature">(
    self,
    length=None,
    checker=None,
    mock_sample=None,
    mock_length=None,
    mock=False
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">checker</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mock_sample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mock_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mock</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A quick and simple way of switching to a mock dataset at the end of a pipeline.</span>

<span class="sd">        Use with `loader = loader.test(mock_sample=..., mock_length=...)</span>
<span class="sd">        You can turn on mocking with `loader.mock = True`</span>

<span class="sd">        :param length: length of the dataset</span>
<span class="sd">        :param checker: any kind of final checking function you want to run over samples</span>
<span class="sd">        :param mock_sample: mock sample</span>
<span class="sd">        :param mock_length: size of mocked dataset</span>
<span class="sd">        :param mock: turning mocking on/off</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span>
            <span class="n">DatasetTest</span><span class="p">,</span>
            <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
            <span class="n">checker</span><span class="o">=</span><span class="n">checker</span><span class="p">,</span>
            <span class="n">mock_sample</span><span class="o">=</span><span class="n">mock_sample</span><span class="p">,</span>
            <span class="n">mock_length</span><span class="o">=</span><span class="n">mock_length</span><span class="p">,</span>
            <span class="n">mock</span><span class="o">=</span><span class="n">mock</span><span class="p">,</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>A quick and simple way of switching to a mock dataset at the end of a pipeline.</p>

<p>Use with <code>loader = loader.test(mock_sample=..., mock_length=...)
You can turn on mocking with</code>loader.mock = True`</p>

<p>:param length: length of the dataset
:param checker: any kind of final checking function you want to run over samples
:param mock_sample: mock sample
:param mock_length: size of mocked dataset
:param mock: turning mocking on/off</p>
</div>


                            </div>
                            <div id="Shorthands.ddp_equalize" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Shorthands.ddp_equalize">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ddp_equalize</span><span class="signature">(self, length)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ddp_equalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equalize number of training samples in DistributedDataParallel training.</span>

<span class="sd">        Torch&#39;s DistributedDataParallel requires the same number of samples in</span>
<span class="sd">        all participating compute nodes.</span>

<span class="sd">        Use with `loader = loader.ddp_equalize(number_of_batches)`</span>


<span class="sd">        You need to specify the number of batches you want to equalize to.</span>
<span class="sd">        This is usually the number of samples in the dataset divided by the batch size.</span>

<span class="sd">        :param length: number of batches in the dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">torch.distributed</span>

        <span class="n">world_size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">distributed</span><span class="o">.</span><span class="n">is_initialized</span><span class="p">():</span>
            <span class="n">world_size</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">distributed</span><span class="o">.</span><span class="n">get_world_size</span><span class="p">()</span>
        <span class="n">numbatches</span> <span class="o">=</span> <span class="n">length</span> <span class="o">//</span> <span class="n">world_size</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">999999999</span><span class="p">)</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">numbatches</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">numbatches</span>
        <span class="k">return</span> <span class="n">result</span>
</pre></div>

        </details>

            <div class="docstring"><p>Equalize number of training samples in DistributedDataParallel training.</p>

<p>Torch's DistributedDataParallel requires the same number of samples in
all participating compute nodes.</p>

<p>Use with <code>loader = loader.ddp_equalize(number_of_batches)</code></p>

<p>You need to specify the number of batches you want to equalize to.
This is usually the number of samples in the dataset divided by the batch size.</p>

<p>:param length: number of batches in the dataset</p>
</div>


                            </div>
                </section>
                <section id="Repeatedly">
                                <div class="attr class">
        <a class="headerlink" href="#Repeatedly">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Repeatedly</span><wbr>(<span class="base">torch.utils.data.dataset.Dataset[+T_co]</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Repeatedly</span><span class="p">(</span><span class="n">IterableDataset</span><span class="p">,</span> <span class="n">Composable</span><span class="p">,</span> <span class="n">Shorthands</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Repeatedly yield samples from a dataset.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nepochs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nbatches</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batchsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an instance of Repeatedly.</span>

<span class="sd">        :param nepochs: repeat for a maximum of nepochs</span>
<span class="sd">        :param nbatches: repeat for a maximum of nbatches</span>
<span class="sd">        :param nsamples: repeat for a maximum of nsamples (requires batchsize)</span>
<span class="sd">        :param batchsize: integer or function of sample returning batch size</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nepochs</span> <span class="o">=</span> <span class="n">nepochs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbatches</span> <span class="o">=</span> <span class="n">nbatches</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batchsize</span> <span class="o">=</span> <span class="n">batchsize</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator that iterates repeatedly over a source.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">repeatedly</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">nepochs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nepochs</span><span class="p">,</span> <span class="n">nbatches</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nbatches</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">batchsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batchsize</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the length of the source.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nepochs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nepochs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbatches</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbatches</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can&#39;t compute size for nsamples; please specify with length= argument&quot;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Repeatedly yield samples from a dataset.</p>
</div>


                            <div id="Repeatedly.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Repeatedly.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Repeatedly</span><span class="signature">(
    nepochs=None,
    nbatches=None,
    nsamples=None,
    batchsize=None,
    length=None
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nepochs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nbatches</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batchsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an instance of Repeatedly.</span>

<span class="sd">        :param nepochs: repeat for a maximum of nepochs</span>
<span class="sd">        :param nbatches: repeat for a maximum of nbatches</span>
<span class="sd">        :param nsamples: repeat for a maximum of nsamples (requires batchsize)</span>
<span class="sd">        :param batchsize: integer or function of sample returning batch size</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nepochs</span> <span class="o">=</span> <span class="n">nepochs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbatches</span> <span class="o">=</span> <span class="n">nbatches</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batchsize</span> <span class="o">=</span> <span class="n">batchsize</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create an instance of Repeatedly.</p>

<p>:param nepochs: repeat for a maximum of nepochs
:param nbatches: repeat for a maximum of nbatches
:param nsamples: repeat for a maximum of nsamples (requires batchsize)
:param batchsize: integer or function of sample returning batch size</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Composable">Composable</a></dt>
                                <dd id="Repeatedly.source_" class="function"><a href="#Composable.source_">source_</a></dd>
                <dd id="Repeatedly.then" class="function"><a href="#Composable.then">then</a></dd>
                <dd id="Repeatedly.compose" class="function"><a href="#Composable.compose">compose</a></dd>

            </div>
            <div><dt><a href="#Shorthands">Shorthands</a></dt>
                                <dd id="Repeatedly.batched" class="function"><a href="#Shorthands.batched">batched</a></dd>
                <dd id="Repeatedly.unbatched" class="function"><a href="#Shorthands.unbatched">unbatched</a></dd>
                <dd id="Repeatedly.shuffle" class="function"><a href="#Shorthands.shuffle">shuffle</a></dd>
                <dd id="Repeatedly.map" class="function"><a href="#Shorthands.map">map</a></dd>
                <dd id="Repeatedly.decode" class="function"><a href="#Shorthands.decode">decode</a></dd>
                <dd id="Repeatedly.rename" class="function"><a href="#Shorthands.rename">rename</a></dd>
                <dd id="Repeatedly.map_dict" class="function"><a href="#Shorthands.map_dict">map_dict</a></dd>
                <dd id="Repeatedly.select" class="function"><a href="#Shorthands.select">select</a></dd>
                <dd id="Repeatedly.to_tuple" class="function"><a href="#Shorthands.to_tuple">to_tuple</a></dd>
                <dd id="Repeatedly.map_tuple" class="function"><a href="#Shorthands.map_tuple">map_tuple</a></dd>
                <dd id="Repeatedly.dbcache" class="function"><a href="#Shorthands.dbcache">dbcache</a></dd>
                <dd id="Repeatedly.associate" class="function"><a href="#Shorthands.associate">associate</a></dd>
                <dd id="Repeatedly.slice" class="function"><a href="#Shorthands.slice">slice</a></dd>
                <dd id="Repeatedly.rsample" class="function"><a href="#Shorthands.rsample">rsample</a></dd>
                <dd id="Repeatedly.repeat" class="function"><a href="#Shorthands.repeat">repeat</a></dd>
                <dd id="Repeatedly.test" class="function"><a href="#Shorthands.test">test</a></dd>
                <dd id="Repeatedly.ddp_equalize" class="function"><a href="#Shorthands.ddp_equalize">ddp_equalize</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="Processor">
                                <div class="attr class">
        <a class="headerlink" href="#Processor">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Processor</span><wbr>(<span class="base">torch.utils.data.dataset.Dataset[+T_co]</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Processor</span><span class="p">(</span><span class="n">IterableDataset</span><span class="p">,</span> <span class="n">Composable</span><span class="p">,</span> <span class="n">Shorthands</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class that turns a function into an IterableDataset.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">_kwa</span><span class="o">=</span><span class="p">{},</span> <span class="n">length</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a processor.</span>

<span class="sd">        The function should take an iterator as an argument and yield</span>
<span class="sd">        processed samples. The function is invoked as `f(source, *args, **kw)`.</span>

<span class="sd">        The `length` can be specified as `True`, in which case the value</span>
<span class="sd">        is taken from the source dataset, as a callable, in which case</span>
<span class="sd">        the length is the result of applying the callable to the source</span>
<span class="sd">        dataset, or as an integer, in which case the length returned by</span>
<span class="sd">        `__len__` is that integer.</span>

<span class="sd">        :param source: source dataset, an IterableDataset</span>
<span class="sd">        :param f: function implementing the processor</span>
<span class="sd">        :param args: extra arguments to the processor after the source iterator</span>
<span class="sd">        :param _kwa: keyword arguments</span>
<span class="sd">        :param length: specified length for the output</span>
<span class="sd">        :param kw: extra keyword arguments</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">_kwa</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>

    <span class="k">def</span> <span class="nf">source_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the source dataset.</span>

<span class="sd">        :param source: source dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator over the source dataset processed by the given function.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;must set source before calling iter </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">),</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the length of this dataset; see above how this is computed.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="si">}</span><span class="s2">: not a valid length specification&quot;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>A class that turns a function into an IterableDataset.</p>
</div>


                            <div id="Processor.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Processor.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Processor</span><span class="signature">(source, f, *args, _kwa={}, length=True, **kw)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">_kwa</span><span class="o">=</span><span class="p">{},</span> <span class="n">length</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a processor.</span>

<span class="sd">        The function should take an iterator as an argument and yield</span>
<span class="sd">        processed samples. The function is invoked as `f(source, *args, **kw)`.</span>

<span class="sd">        The `length` can be specified as `True`, in which case the value</span>
<span class="sd">        is taken from the source dataset, as a callable, in which case</span>
<span class="sd">        the length is the result of applying the callable to the source</span>
<span class="sd">        dataset, or as an integer, in which case the length returned by</span>
<span class="sd">        `__len__` is that integer.</span>

<span class="sd">        :param source: source dataset, an IterableDataset</span>
<span class="sd">        :param f: function implementing the processor</span>
<span class="sd">        :param args: extra arguments to the processor after the source iterator</span>
<span class="sd">        :param _kwa: keyword arguments</span>
<span class="sd">        :param length: specified length for the output</span>
<span class="sd">        :param kw: extra keyword arguments</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">_kwa</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create a processor.</p>

<p>The function should take an iterator as an argument and yield
processed samples. The function is invoked as <code>f(source, *args, **kw)</code>.</p>

<p>The <code>length</code> can be specified as <code>True</code>, in which case the value
is taken from the source dataset, as a callable, in which case
the length is the result of applying the callable to the source
dataset, or as an integer, in which case the length returned by
<code>__len__</code> is that integer.</p>

<p>:param source: source dataset, an IterableDataset
:param f: function implementing the processor
:param args: extra arguments to the processor after the source iterator
:param _kwa: keyword arguments
:param length: specified length for the output
:param kw: extra keyword arguments</p>
</div>


                            </div>
                            <div id="Processor.source_" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Processor.source_">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">source_</span><span class="signature">(self, source)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">source_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the source dataset.</span>

<span class="sd">        :param source: source dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="k">return</span> <span class="bp">self</span>
</pre></div>

        </details>

            <div class="docstring"><p>Set the source dataset.</p>

<p>:param source: source dataset</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Composable">Composable</a></dt>
                                <dd id="Processor.then" class="function"><a href="#Composable.then">then</a></dd>
                <dd id="Processor.compose" class="function"><a href="#Composable.compose">compose</a></dd>

            </div>
            <div><dt><a href="#Shorthands">Shorthands</a></dt>
                                <dd id="Processor.batched" class="function"><a href="#Shorthands.batched">batched</a></dd>
                <dd id="Processor.unbatched" class="function"><a href="#Shorthands.unbatched">unbatched</a></dd>
                <dd id="Processor.shuffle" class="function"><a href="#Shorthands.shuffle">shuffle</a></dd>
                <dd id="Processor.map" class="function"><a href="#Shorthands.map">map</a></dd>
                <dd id="Processor.decode" class="function"><a href="#Shorthands.decode">decode</a></dd>
                <dd id="Processor.rename" class="function"><a href="#Shorthands.rename">rename</a></dd>
                <dd id="Processor.map_dict" class="function"><a href="#Shorthands.map_dict">map_dict</a></dd>
                <dd id="Processor.select" class="function"><a href="#Shorthands.select">select</a></dd>
                <dd id="Processor.to_tuple" class="function"><a href="#Shorthands.to_tuple">to_tuple</a></dd>
                <dd id="Processor.map_tuple" class="function"><a href="#Shorthands.map_tuple">map_tuple</a></dd>
                <dd id="Processor.dbcache" class="function"><a href="#Shorthands.dbcache">dbcache</a></dd>
                <dd id="Processor.associate" class="function"><a href="#Shorthands.associate">associate</a></dd>
                <dd id="Processor.slice" class="function"><a href="#Shorthands.slice">slice</a></dd>
                <dd id="Processor.rsample" class="function"><a href="#Shorthands.rsample">rsample</a></dd>
                <dd id="Processor.repeat" class="function"><a href="#Shorthands.repeat">repeat</a></dd>
                <dd id="Processor.test" class="function"><a href="#Shorthands.test">test</a></dd>
                <dd id="Processor.ddp_equalize" class="function"><a href="#Shorthands.ddp_equalize">ddp_equalize</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="WebDataset">
                            <div class="attr function"><a class="headerlink" href="#WebDataset">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WebDataset</span><span class="signature">(
    urls,
    shardshuffle=True,
    cache_dir=&#39;&#39;,
    cache_size=1000000000000000,
    cache_name=&lt;function shard_uuid&gt;,
    cache_verbose=1,
    splitter=&lt;function split_by_worker&gt;,
    nodesplitter=True,
    handler=&lt;function reraise_exception&gt;,
    length=None,
    warn_empty=True
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">WebDataset</span><span class="p">(</span>
    <span class="n">urls</span><span class="p">,</span>
    <span class="n">shardshuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">cache_dir</span><span class="o">=</span><span class="n">default_cache_dir</span><span class="p">,</span>
    <span class="n">cache_size</span><span class="o">=</span><span class="n">default_cache_size</span><span class="p">,</span>
    <span class="n">cache_name</span><span class="o">=</span><span class="n">default_cache_name</span><span class="p">,</span>
    <span class="n">cache_verbose</span><span class="o">=</span><span class="n">default_cache_verbose</span><span class="p">,</span>
    <span class="n">splitter</span><span class="o">=</span><span class="n">split_by_worker</span><span class="p">,</span>
    <span class="n">nodesplitter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">handler</span><span class="o">=</span><span class="n">reraise_exception</span><span class="p">,</span>
    <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">warn_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a pipeline for WebDataset-style data files.</span>

<span class="sd">    This is a convenience function for constructing a partial pipeline</span>
<span class="sd">    that reads from a set of sharded tar files, extracts the individual</span>
<span class="sd">    files, and groups them together into samples (dictionaries).</span>

<span class="sd">    You can use all the methods from `Composable` (`then`, `compose`) and</span>
<span class="sd">    from `Shorthands` (`batched`, `unbatched`, `decode`, `shuffle`, etc.)</span>
<span class="sd">    on the result.</span>

<span class="sd">    :param urls: the source URLs, specified either as a list or as a brace-expanded string</span>
<span class="sd">    :param shardshuffle: boolean indicating whether the shards should be shuffled or not</span>
<span class="sd">    :param splitter: a function called for splitting shards among workers (True: PyTorch default, None: no splitting)</span>
<span class="sd">    :param nodesplitter: a function called for splitting shards among nodes (True: PyTorch default, None: no splitting)</span>
<span class="sd">    :param handler: an error handler</span>
<span class="sd">    :param length: the length of this dataset, should be an integer</span>
<span class="sd">    :param cache_dir: when set, caches shards in this directory</span>
<span class="sd">    :param cache_size: when set, specifies a maximum size for the shard cache</span>
<span class="sd">    :param cache_name: when set, specifies how shards should be named in the cache</span>
<span class="sd">    :param cache_verbose: when set, prints information about caching</span>
<span class="sd">    :param warn_empty: warn when no samples are generated at all</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">ShardList</span><span class="p">(</span>
        <span class="n">urls</span><span class="p">,</span>
        <span class="n">shuffle</span><span class="o">=</span><span class="n">shardshuffle</span><span class="p">,</span>
        <span class="n">splitter</span><span class="o">=</span><span class="n">splitter</span><span class="p">,</span>
        <span class="n">nodesplitter</span><span class="o">=</span><span class="n">nodesplitter</span><span class="p">,</span>
        <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">tariterators</span><span class="o">.</span><span class="n">url_opener</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">handler</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cache_dir</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">then</span><span class="p">(</span>
            <span class="n">shardcache</span><span class="o">.</span><span class="n">cache_shards</span><span class="p">,</span>
            <span class="n">cache_dir</span><span class="o">=</span><span class="n">cache_dir</span><span class="p">,</span>
            <span class="n">cache_size</span><span class="o">=</span><span class="n">cache_size</span><span class="p">,</span>
            <span class="n">cache_name</span><span class="o">=</span><span class="n">cache_name</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">cache_verbose</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">tariterators</span><span class="o">.</span><span class="n">tar_file_expander</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">handler</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">tariterators</span><span class="o">.</span><span class="n">group_by_keys</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">warn_empty</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">warn_no_samples</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return a pipeline for WebDataset-style data files.</p>

<p>This is a convenience function for constructing a partial pipeline
that reads from a set of sharded tar files, extracts the individual
files, and groups them together into samples (dictionaries).</p>

<p>You can use all the methods from <code><a href="#Composable">Composable</a></code> (<code>then</code>, <code>compose</code>) and
from <code><a href="#Shorthands">Shorthands</a></code> (<code>batched</code>, <code>unbatched</code>, <code>decode</code>, <code>shuffle</code>, etc.)
on the result.</p>

<p>:param urls: the source URLs, specified either as a list or as a brace-expanded string
:param shardshuffle: boolean indicating whether the shards should be shuffled or not
:param splitter: a function called for splitting shards among workers (True: PyTorch default, None: no splitting)
:param nodesplitter: a function called for splitting shards among nodes (True: PyTorch default, None: no splitting)
:param handler: an error handler
:param length: the length of this dataset, should be an integer
:param cache_dir: when set, caches shards in this directory
:param cache_size: when set, specifies a maximum size for the shard cache
:param cache_name: when set, specifies how shards should be named in the cache
:param cache_verbose: when set, prints information about caching
:param warn_empty: warn when no samples are generated at all</p>
</div>


                </section>
                <section id="WebLoader">
                            <div class="attr function"><a class="headerlink" href="#WebLoader">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WebLoader</span><span class="signature">(*args, **kw)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">WebLoader</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a small wrapper around torch.utils.data.DataLoader.</span>

<span class="sd">    This wrapper works identically to the original `DataLoader`, but adds</span>
<span class="sd">    alls the convenience functions and filters for WebDataset.</span>

<span class="sd">    You can use all the methods from `Composable` (`then`, `compose`) and</span>
<span class="sd">    from `Shorthands` (`batched`, `unbatched`, `decode`, `shuffle`, etc.)</span>
<span class="sd">    on the result.</span>

<span class="sd">    :param args: forwarded to `DataLoader`</span>
<span class="sd">    :param kw: forwarded to `DataLoader`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Processor</span><span class="p">(</span><span class="n">DataLoader</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">),</span> <span class="n">utils</span><span class="o">.</span><span class="n">identity</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return a small wrapper around torch.utils.data.DataLoader.</p>

<p>This wrapper works identically to the original <code>DataLoader</code>, but adds
alls the convenience functions and filters for WebDataset.</p>

<p>You can use all the methods from <code><a href="#Composable">Composable</a></code> (<code>then</code>, <code>compose</code>) and
from <code><a href="#Shorthands">Shorthands</a></code> (<code>batched</code>, <code>unbatched</code>, <code>decode</code>, <code>shuffle</code>, etc.)
on the result.</p>

<p>:param args: forwarded to <code>DataLoader</code>
:param kw: forwarded to <code>DataLoader</code></p>
</div>


                </section>
                <section id="DatasetTest">
                                <div class="attr class">
        <a class="headerlink" href="#DatasetTest">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">DatasetTest</span><wbr>(<span class="base">torch.utils.data.dataset.Dataset[+T_co]</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">DatasetTest</span><span class="p">(</span><span class="n">IterableDataset</span><span class="p">,</span> <span class="n">Composable</span><span class="p">,</span> <span class="n">Shorthands</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform final checks on an IterableDataset and permit easy mock tests.</span>

<span class="sd">    This is the implementation of the `Shorthands.test` method; you usually</span>
<span class="sd">    do not need to construct it explicitly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">checker</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mock_sample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mock_length</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">mock</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a DatasetTest.</span>

<span class="sd">        :param length: length of the dataset</span>
<span class="sd">        :param checker: any kind of final checking function you want to run over samples</span>
<span class="sd">        :param mock_sample: mock sample</span>
<span class="sd">        :param mock_length: size of mocked dataset</span>
<span class="sd">        :param mock: turning mocking on/off</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checker</span> <span class="o">=</span> <span class="n">checker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mock</span> <span class="o">=</span> <span class="n">mock</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mock_length</span> <span class="o">=</span> <span class="n">mock_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mock_sample</span> <span class="o">=</span> <span class="n">mock_sample</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the length of the test object.</span>

<span class="sd">        This is either the length of the mock object when in mock mode,</span>
<span class="sd">        otherwise the length of the underlying dataset/data loader.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mock</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mock_length</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="si">}</span><span class="s2">: not a valid length specification&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator either over the mock object or the underlying dataset.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mock</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mock_sample</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mock_length</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">mock_sample</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mock_sample</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">checker</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">checker</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">sample</span>
</pre></div>

        </details>

            <div class="docstring"><p>Perform final checks on an IterableDataset and permit easy mock tests.</p>

<p>This is the implementation of the <code><a href="#Shorthands.test">Shorthands.test</a></code> method; you usually
do not need to construct it explicitly.</p>
</div>


                            <div id="DatasetTest.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DatasetTest.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">DatasetTest</span><span class="signature">(
    length=None,
    checker=None,
    mock_sample=None,
    mock_length=10000,
    mock=False
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">checker</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mock_sample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mock_length</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">mock</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a DatasetTest.</span>

<span class="sd">        :param length: length of the dataset</span>
<span class="sd">        :param checker: any kind of final checking function you want to run over samples</span>
<span class="sd">        :param mock_sample: mock sample</span>
<span class="sd">        :param mock_length: size of mocked dataset</span>
<span class="sd">        :param mock: turning mocking on/off</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checker</span> <span class="o">=</span> <span class="n">checker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mock</span> <span class="o">=</span> <span class="n">mock</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mock_length</span> <span class="o">=</span> <span class="n">mock_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mock_sample</span> <span class="o">=</span> <span class="n">mock_sample</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create a DatasetTest.</p>

<p>:param length: length of the dataset
:param checker: any kind of final checking function you want to run over samples
:param mock_sample: mock sample
:param mock_length: size of mocked dataset
:param mock: turning mocking on/off</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Composable">Composable</a></dt>
                                <dd id="DatasetTest.source_" class="function"><a href="#Composable.source_">source_</a></dd>
                <dd id="DatasetTest.then" class="function"><a href="#Composable.then">then</a></dd>
                <dd id="DatasetTest.compose" class="function"><a href="#Composable.compose">compose</a></dd>

            </div>
            <div><dt><a href="#Shorthands">Shorthands</a></dt>
                                <dd id="DatasetTest.batched" class="function"><a href="#Shorthands.batched">batched</a></dd>
                <dd id="DatasetTest.unbatched" class="function"><a href="#Shorthands.unbatched">unbatched</a></dd>
                <dd id="DatasetTest.shuffle" class="function"><a href="#Shorthands.shuffle">shuffle</a></dd>
                <dd id="DatasetTest.map" class="function"><a href="#Shorthands.map">map</a></dd>
                <dd id="DatasetTest.decode" class="function"><a href="#Shorthands.decode">decode</a></dd>
                <dd id="DatasetTest.rename" class="function"><a href="#Shorthands.rename">rename</a></dd>
                <dd id="DatasetTest.map_dict" class="function"><a href="#Shorthands.map_dict">map_dict</a></dd>
                <dd id="DatasetTest.select" class="function"><a href="#Shorthands.select">select</a></dd>
                <dd id="DatasetTest.to_tuple" class="function"><a href="#Shorthands.to_tuple">to_tuple</a></dd>
                <dd id="DatasetTest.map_tuple" class="function"><a href="#Shorthands.map_tuple">map_tuple</a></dd>
                <dd id="DatasetTest.dbcache" class="function"><a href="#Shorthands.dbcache">dbcache</a></dd>
                <dd id="DatasetTest.associate" class="function"><a href="#Shorthands.associate">associate</a></dd>
                <dd id="DatasetTest.slice" class="function"><a href="#Shorthands.slice">slice</a></dd>
                <dd id="DatasetTest.rsample" class="function"><a href="#Shorthands.rsample">rsample</a></dd>
                <dd id="DatasetTest.repeat" class="function"><a href="#Shorthands.repeat">repeat</a></dd>
                <dd id="DatasetTest.test" class="function"><a href="#Shorthands.test">test</a></dd>
                <dd id="DatasetTest.ddp_equalize" class="function"><a href="#Shorthands.ddp_equalize">ddp_equalize</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="ChoppedDataset">
                                <div class="attr class">
        <a class="headerlink" href="#ChoppedDataset">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">ChoppedDataset</span><wbr>(<span class="base">torch.utils.data.dataset.Dataset[+T_co]</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">ChoppedDataset</span><span class="p">(</span><span class="n">IterableDataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Change the actual and nominal length of an IterableDataset.</span>

<span class="sd">    This will continuously iterate through the original dataset, but</span>
<span class="sd">    impose new epoch boundaries at the given length/nominal.</span>
<span class="sd">    This exists mainly as a workaround for the odd logic in DataLoader.</span>
<span class="sd">    It is also useful for choosing smaller nominal epoch sizes with</span>
<span class="sd">    very large datasets.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nominal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a ChoppedDataset.</span>

<span class="sd">        :param dataset: IterableDataset</span>
<span class="sd">        :param length: declared length of the dataset</span>
<span class="sd">        :param nominal: nominal length of dataset (if different from declared)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span>
        <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nominal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="k">if</span> <span class="n">nominal</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">nominal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the length of the dataset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nominal</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the pickled state of the dataset.</span>

<span class="sd">        This resets the dataset iterator, since that can&#39;t be pickled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator over the dataset.</span>

<span class="sd">        This iterator returns as many samples as given by the `length` parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">sample</span>
</pre></div>

        </details>

            <div class="docstring"><p>Change the actual and nominal length of an IterableDataset.</p>

<p>This will continuously iterate through the original dataset, but
impose new epoch boundaries at the given length/nominal.
This exists mainly as a workaround for the odd logic in DataLoader.
It is also useful for choosing smaller nominal epoch sizes with
very large datasets.</p>
</div>


                            <div id="ChoppedDataset.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#ChoppedDataset.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">ChoppedDataset</span><span class="signature">(dataset, length=None, nominal=None)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nominal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a ChoppedDataset.</span>

<span class="sd">        :param dataset: IterableDataset</span>
<span class="sd">        :param length: declared length of the dataset</span>
<span class="sd">        :param nominal: nominal length of dataset (if different from declared)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span>
        <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nominal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="k">if</span> <span class="n">nominal</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">nominal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create a ChoppedDataset.</p>

<p>:param dataset: IterableDataset
:param length: declared length of the dataset
:param nominal: nominal length of dataset (if different from declared)</p>
</div>


                            </div>
                </section>
                <section id="ResizedDataset">
                                <div class="attr class">
        <a class="headerlink" href="#ResizedDataset">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">ResizedDataset</span><wbr>(<span class="base">torch.utils.data.dataset.Dataset[+T_co]</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">ChoppedDataset</span><span class="p">(</span><span class="n">IterableDataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Change the actual and nominal length of an IterableDataset.</span>

<span class="sd">    This will continuously iterate through the original dataset, but</span>
<span class="sd">    impose new epoch boundaries at the given length/nominal.</span>
<span class="sd">    This exists mainly as a workaround for the odd logic in DataLoader.</span>
<span class="sd">    It is also useful for choosing smaller nominal epoch sizes with</span>
<span class="sd">    very large datasets.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nominal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a ChoppedDataset.</span>

<span class="sd">        :param dataset: IterableDataset</span>
<span class="sd">        :param length: declared length of the dataset</span>
<span class="sd">        :param nominal: nominal length of dataset (if different from declared)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span>
        <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nominal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="k">if</span> <span class="n">nominal</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">nominal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the length of the dataset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nominal</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the pickled state of the dataset.</span>

<span class="sd">        This resets the dataset iterator, since that can&#39;t be pickled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator over the dataset.</span>

<span class="sd">        This iterator returns as many samples as given by the `length` parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">sample</span>
</pre></div>

        </details>

            <div class="docstring"><p>Change the actual and nominal length of an IterableDataset.</p>

<p>This will continuously iterate through the original dataset, but
impose new epoch boundaries at the given length/nominal.
This exists mainly as a workaround for the odd logic in DataLoader.
It is also useful for choosing smaller nominal epoch sizes with
very large datasets.</p>
</div>


                            <div id="ResizedDataset.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#ResizedDataset.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">ResizedDataset</span><span class="signature">(dataset, length=None, nominal=None)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nominal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a ChoppedDataset.</span>

<span class="sd">        :param dataset: IterableDataset</span>
<span class="sd">        :param length: declared length of the dataset</span>
<span class="sd">        :param nominal: nominal length of dataset (if different from declared)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span>
        <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nominal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="k">if</span> <span class="n">nominal</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">nominal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create a ChoppedDataset.</p>

<p>:param dataset: IterableDataset
:param length: declared length of the dataset
:param nominal: nominal length of dataset (if different from declared)</p>
</div>


                            </div>
                </section>
    </main>
        <script>/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();</script>
        <script>
            function escapeHTML(html) {
                return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
            }

            const originalContent = document.querySelector("main.pdoc");
            let currentContent = originalContent;

            function setContent(innerHTML) {
                let elem;
                if (innerHTML) {
                    elem = document.createElement("main");
                    elem.classList.add("pdoc");
                    elem.innerHTML = innerHTML;
                } else {
                    elem = originalContent;
                }
                if (currentContent !== elem) {
                    currentContent.replaceWith(elem);
                    currentContent = elem;
                }
            }

            function getSearchTerm() {
                return (new URL(window.location)).searchParams.get("search");
            }

            const searchBox = document.querySelector(".pdoc input[type=search]");
            searchBox.addEventListener("input", function () {
                let url = new URL(window.location);
                if (searchBox.value.trim()) {
                    url.hash = "";
                    url.searchParams.set("search", searchBox.value);
                } else {
                    url.searchParams.delete("search");
                }
                history.replaceState("", "", url.toString());
                onInput();
            });
            window.addEventListener("popstate", onInput);


            let searchIndex, searchErr;

            async function initialize() {
                let docs;
                try {
                    let resp = await fetch("../search.json");
                    docs = await resp.json();
                } catch (e) {
                    searchErr = "Cannot fetch search index.";
                    throw e;
                }

                // Also split on html tags. this is a cheap heuristic, but good enough.
                elasticlunr.tokenizer.setSeperator(/[\s\-.;&]+|<[^>]*>/);

                if (docs._isPrebuiltIndex) {
                    console.info("using precompiled search index");
                    searchIndex = elasticlunr.Index.load(docs);
                } else {
                    console.time("building search index");
                    searchIndex = elasticlunr(function () {
                        this.addField('qualname');
                        this.addField('fullname');
                        this.addField('doc');
                        this.setRef('fullname');
                    });
                    for (let doc of docs) {
                        searchIndex.addDoc(doc);
                    }
                    console.timeEnd("building search index");
                }
                onInput();

                document.querySelector("nav.pdoc").addEventListener("click", e => {
                    if (e.target.hash) {
                        searchBox.value = "";
                        searchBox.dispatchEvent(new Event("input"));
                    }
                });
            }

            function onInput() {
                setContent((() => {
                    const search = getSearchTerm();
                    if (!search) {
                        return null
                    }
                    if (searchErr) {
                        return `<h3>Error: ${searchErr}</h3>`
                    }
                    if (!searchIndex) {
                        return "<h3>Searching...</h3>"
                    }

                    window.scrollTo({top: 0, left: 0, behavior: 'auto'});

                    const results = searchIndex.search(search, {
                        fields: {
                            qualname: {boost: 4},
                            fullname: {boost: 2},
                            doc: {boost: 1},
                        },
                        expand: true
                    });

                    let html;
                    if (results.length === 0) {
                        html = `No search results for '${escapeHTML(search)}'.`
                    } else {
                        html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(search)}'.</h4>`;
                    }
                    for (let result of results.slice(0, 10)) {
                        let doc = result.doc;
                        let url = `../${doc.modulename.replaceAll(".", "/")}.html`;
                        if (doc.qualname) {
                            url += `#${doc.qualname}`;
                        }

                        let heading;
                        switch (result.doc.type) {
                            case "function":
                                heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span><span class="signature">(${doc.parameters.join(", ")})</span>`;
                                break;
                            case "class":
                                heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                                break;
                            default:
                                heading = `<span class="name">${doc.fullname}</span>`;
                                break;
                        }
                        html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

                    }
                    return html;
                })());
            }

            if (getSearchTerm()) {
                initialize();
                searchBox.value = getSearchTerm();
                onInput();
            } else {
                searchBox.addEventListener("focus", initialize, {once: true});
            }

            searchBox.addEventListener("keydown", e => {
                if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
                    let focused = currentContent.querySelector(".search-result.focused");
                    if (!focused) {
                        currentContent.querySelector(".search-result").classList.add("focused");
                    } else if (
                        e.key === "ArrowDown"
                        && focused.nextElementSibling
                        && focused.nextElementSibling.classList.contains("search-result")
                    ) {
                        focused.classList.remove("focused");
                        focused.nextElementSibling.classList.add("focused");
                        focused.nextElementSibling.scrollIntoView({
                            behavior: "smooth",
                            block: "nearest",
                            inline: "nearest"
                        });
                    } else if (
                        e.key === "ArrowUp"
                        && focused.previousElementSibling
                        && focused.previousElementSibling.classList.contains("search-result")
                    ) {
                        focused.classList.remove("focused");
                        focused.previousElementSibling.classList.add("focused");
                        focused.previousElementSibling.scrollIntoView({
                            behavior: "smooth",
                            block: "nearest",
                            inline: "nearest"
                        });
                    } else if (
                        e.key === "Enter"
                    ) {
                        focused.querySelector("a").click();
                    }
                }
            });
        </script>
</body>
</html>